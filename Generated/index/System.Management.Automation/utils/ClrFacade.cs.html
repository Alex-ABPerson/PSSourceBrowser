<!DOCTYPE html>
<html><head><title>ClrFacade.cs</title><link rel="stylesheet" href="../../styles.css"><script src="../../scripts.js"></script></head>
<body class="cB" onload="i(396);"><div class="dH">
<table style="width: 100%">
<tr><td>File: <a id="filePath" class="blueLink" href="/#System.Management.Automation/utils/ClrFacade.cs" target="_top">utils\ClrFacade.cs</a><br/></td><td></td></tr>
<tr><td>Project: <a id="projectPath" class="blueLink" href="/#System.Management.Automation" target="_top">src\System.Management.Automation\System.Management.Automation.csproj</a> (System.Management.Automation)</td></tr>
</table>
</div>
<div class="cz"><table class="tb" cellpadding="0" cellspacing="0"><tr><td valign="top" align="right"><pre id="ln"></pre></td><td valign="top" align="left"><pre id="code">
<span class="c">// Copyright (c) Microsoft Corporation.</span>
<span class="c">// Licensed under the MIT License.</span>
 
<b>using</b> <span class="i n">System</span>.<span class="i">Collections</span>.<span class="i">Generic</span>;
<b>using</b> <span class="i n">System</span>.<span class="i">Globalization</span>;
<b>using</b> <span class="i n">System</span>.<span class="i">IO</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Management</span>.<span class="i n">Automation</span>.<span class="i n">Internal</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Management</span>.<span class="i n">Automation</span>.<span class="i n">Language</span>;
<b>using</b> <span class="i n">System</span>.<span class="i">Reflection</span>;
<b>using</b> <span class="i n">System</span>.<span class="i">Runtime</span>.<span class="i">InteropServices</span>;
<b>using</b> <span class="i n">System</span>.<span class="i">Runtime</span>.<span class="i">Loader</span>;
<b>using</b> <span class="i n">System</span>.<span class="i">Security</span>;
<b>using</b> <span class="i n">System</span>.<span class="i">Text</span>;
<b>using</b> <span class="i n">System</span>.<span class="i">Text</span>.<span class="i">RegularExpressions</span>;
 
<b>namespace</b> <span class="i n">System</span>.<span class="i n">Management</span>.<span class="i n">Automation</span>
{
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> ClrFacade contains all diverging code (different implementation for FullCLR and CoreCLR using if/def).</span>
    <span class="c">///</span><span class="c"> It exposes common APIs that can be used by the rest of the code base.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
    <b>internal static class</b> <a id="a9a016478ec73a42" href="../R/a9a016478ec73a42.html" target="n" data-glyph="2,0" class="t t">ClrFacade</a>
    {
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Initialize powershell AssemblyLoadContext and register the &#39;Resolving&#39; event, if it&#39;s not done already.</span>
        <span class="c">///</span><span class="c"> If powershell is hosted by a native host such as DSC, then PS ALC might be initialized via &#39;SetPowerShellAssemblyLoadContext&#39; before loading S.M.A.</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
        <b>static</b> <a id="833e9f17da1f9b61" href="../R/../../0000000000.html" target="n" data-glyph="76,1" class="t method">ClrFacade</a>()
        {
            <b>if</b> (<a href="../CoreCLR/CorePsAssemblyLoadContext.cs.html#606826c84576695c" class="t t">PowerShellAssemblyLoadContext</a>.<a href="../CoreCLR/CorePsAssemblyLoadContext.cs.html#c616e674431e58cb" class="i property">Instance</a> == <b>null</b>)
            {
                <a href="../CoreCLR/CorePsAssemblyLoadContext.cs.html#606826c84576695c" class="t t">PowerShellAssemblyLoadContext</a>.<span class="i">InitializeSingleton</span>(<b>string</b>.<span class="i">Empty</span>);
            }
        }
 
        <span class="k preprocess">#</span><span class="k preprocess">region</span> Assembly
 
        <b>internal static</b> <span class="i">IEnumerable</span>&lt;<span class="i">Assembly</span>&gt; <a id="dcc937adf7d0cfeb" href="../R/dcc937adf7d0cfeb.html" target="n" data-glyph="74,1" class="i method">GetAssemblies</a>(<a href="../engine/parser/TypeResolver.cs.html#55992be0fa5b3b24" class="t t">TypeResolutionState</a> <span id="r0 rd" class="r0 r">typeResolutionState</span>, <a href="../engine/parser/ast.cs.html#83b43c1855a09e15" class="t t">TypeName</a> <span id="r1 rd" class="r1 r">typeName</span>)
        {
            <b>string</b> <span id="r2 rd" class="r2 r">typeNameToSearch</span> = <span class="r0 r">typeResolutionState</span>.<a href="../engine/parser/TypeResolver.cs.html#40c65c3ab33e7ce0" class="i method">GetAlternateTypeName</a>(<span class="r1 r">typeName</span>.<a href="../engine/parser/ast.cs.html#a9592c89dfa9c9ad" class="i property">Name</a>) ?? <span class="r1 r">typeName</span>.<a href="../engine/parser/ast.cs.html#a9592c89dfa9c9ad" class="i property">Name</a>;
            <b>return</b> <a href="#0f02ed52d6976720" class="i method">GetAssemblies</a>(<span class="r2 r">typeNameToSearch</span>);
        }
 
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Facade for AppDomain.GetAssemblies.</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span> <span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r3 r">namespaceQualifiedTypeName</span><span class="c">&quot;</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> In CoreCLR context, if it&#39;s for string-to-type conversion and the namespace qualified type name is known, pass it in so that</span>
        <span class="c">///</span><span class="c"> powershell can load the necessary TPA if the target type is from an unloaded TPA.</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
        <b>internal static</b> <span class="i">IEnumerable</span>&lt;<span class="i">Assembly</span>&gt; <a id="0f02ed52d6976720" href="../R/0f02ed52d6976720.html" target="n" data-glyph="74,1" class="i method">GetAssemblies</a>(<b>string</b> <span id="r3 rd" class="r3 r">namespaceQualifiedTypeName</span> = <b>null</b>)
        {
            <b>return</b> <a href="#dde4ae72abf8d232" class="i property">PSAssemblyLoadContext</a>.<a href="../CoreCLR/CorePsAssemblyLoadContext.cs.html#5345a6b5d9ae579b" class="i method">GetAssembly</a>(<span class="r3 r">namespaceQualifiedTypeName</span>) ?? <a href="#1b436df8d00ed705" class="i method">GetPSVisibleAssemblies</a>();
        }
 
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Return assemblies from the default load context and the &#39;individual&#39; load contexts.</span>
        <span class="c">///</span><span class="c"> The &#39;individual&#39; load contexts are the ones holding assemblies loaded via &#39;Assembly.Load(byte[])&#39; and &#39;Assembly.LoadFile&#39;.</span>
        <span class="c">///</span><span class="c"> Assemblies loaded in any custom load contexts are not consider visible to PowerShell to avoid type identity issues.</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
        <b>private static</b> <span class="i">IEnumerable</span>&lt;<span class="i">Assembly</span>&gt; <a id="1b436df8d00ed705" href="../R/1b436df8d00ed705.html" target="n" data-glyph="76,1" class="i method">GetPSVisibleAssemblies</a>()
        {
            <b>const string</b> <span id="r4 rd" class="r4 r">IndividualAssemblyLoadContext</span> = <span class="s">&quot;System.Runtime.Loader.IndividualAssemblyLoadContext&quot;</span>;
 
            <b>foreach</b> (<span class="i">Assembly</span> <span id="r5 rd" class="r5 r">assembly</span> <b>in</b> <span class="i">AssemblyLoadContext</span>.<span class="i">Default</span>.<span class="i">Assemblies</span>)
            {
                <b>if</b> (!<span class="r5 r">assembly</span>.<span class="i">FullName</span>.<span class="i">StartsWith</span>(<a href="../engine/parser/PSType.cs.html#6158471889fabd77" class="t t">TypeDefiner</a>.<a href="../engine/parser/PSType.cs.html#ad22e2e9179304d5" class="i field">DynamicClassAssemblyFullNamePrefix</a>, <span class="i">StringComparison</span>.<span class="i">Ordinal</span>))
                {
                    <b>yield</b> <b>return</b> <span class="r5 r">assembly</span>;
                }
            }
 
            <b>foreach</b> (<span class="i">AssemblyLoadContext</span> <span id="r6 rd" class="r6 r">context</span> <b>in</b> <span class="i">AssemblyLoadContext</span>.<span class="i">All</span>)
            {
                <b>if</b> (<span class="r4 r">IndividualAssemblyLoadContext</span>.<span class="i">Equals</span>(<span class="r6 r">context</span>.<span class="i">GetType</span>().<span class="i">FullName</span>, <span class="i">StringComparison</span>.<span class="i">Ordinal</span>))
                {
                    <b>foreach</b> (<span class="i">Assembly</span> <span id="r7 rd" class="r7 r">assembly</span> <b>in</b> <span class="r6 r">context</span>.<span class="i">Assemblies</span>)
                    {
                        <b>yield</b> <b>return</b> <span class="r7 r">assembly</span>;
                    }
                }
            }
        }
 
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Get the namespace-qualified type names of all available .NET Core types shipped with PowerShell.</span>
        <span class="c">///</span><span class="c"> This is used for type name auto-completion in PS engine.</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
        <b>internal static</b> <span class="i">IEnumerable</span>&lt;<b>string</b>&gt; <a id="2accf5603a160752" href="../R/2accf5603a160752.html" target="n" data-glyph="104,1" class="i property">AvailableDotNetTypeNames</a> =&gt; <a href="#dde4ae72abf8d232" class="i property">PSAssemblyLoadContext</a>.<a href="../CoreCLR/CorePsAssemblyLoadContext.cs.html#21abf15dd9957631" class="i property">AvailableDotNetTypeNames</a>;
 
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Get the assembly names of all available .NET Core assemblies shipped with PowerShell.</span>
        <span class="c">///</span><span class="c"> This is used for type name auto-completion in PS engine.</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
        <b>internal static</b> <span class="i">HashSet</span>&lt;<b>string</b>&gt; <a id="bd2ab28d61e79000" href="../R/bd2ab28d61e79000.html" target="n" data-glyph="104,1" class="i property">AvailableDotNetAssemblyNames</a> =&gt; <a href="#dde4ae72abf8d232" class="i property">PSAssemblyLoadContext</a>.<a href="../CoreCLR/CorePsAssemblyLoadContext.cs.html#5557c0e0687d39b6" class="i property">AvailableDotNetAssemblyNames</a>;
 
        <b>private static</b> <a href="../CoreCLR/CorePsAssemblyLoadContext.cs.html#606826c84576695c" class="t t">PowerShellAssemblyLoadContext</a> <a id="dde4ae72abf8d232" href="../R/dde4ae72abf8d232.html" target="n" data-glyph="106,1" class="i property">PSAssemblyLoadContext</a> =&gt; <a href="../CoreCLR/CorePsAssemblyLoadContext.cs.html#606826c84576695c" class="t t">PowerShellAssemblyLoadContext</a>.<a href="../CoreCLR/CorePsAssemblyLoadContext.cs.html#c616e674431e58cb" class="i property">Instance</a>;
 
        <span class="k preprocess">#</span><span class="k preprocess">endregion</span> Assembly
 
        <span class="k preprocess">#</span><span class="k preprocess">region</span> Encoding
 
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Facade for getting default encoding.</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
        <b>internal static</b> <span class="i">Encoding</span> <a id="0c8a7fc2b80117dd" href="../R/0c8a7fc2b80117dd.html" target="n" data-glyph="74,1" class="i method">GetDefaultEncoding</a>()
        {
            <b>if</b> (<a href="#e0428c24354f6951" class="i field">s_defaultEncoding</a> == <b>null</b>)
            {
                <span class="c">// load all available encodings</span>
                <a href="#c4cb03fb01820e43" class="i method">EncodingRegisterProvider</a>();
                <a href="#e0428c24354f6951" class="i field">s_defaultEncoding</a> = <b>new</b> <span class="i">UTF8Encoding</span>(<b>false</b>);
            }
 
            <b>return</b> <a href="#e0428c24354f6951" class="i field">s_defaultEncoding</a>;
        }
 
        <b>private static volatile</b> <span class="i">Encoding</span> <a id="e0428c24354f6951" href="../R/e0428c24354f6951.html" target="n" data-glyph="46,1" class="i field">s_defaultEncoding</a>;
 
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Facade for getting OEM encoding</span>
        <span class="c">///</span><span class="c"> OEM encodings work on all platforms, or rather codepage 437 is available on both Windows and Non-Windows.</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
        <b>internal static</b> <span class="i">Encoding</span> <a id="83fa3f5277b20291" href="../R/83fa3f5277b20291.html" target="n" data-glyph="74,1" class="i method">GetOEMEncoding</a>()
        {
            <b>if</b> (<a href="#9713d89229054647" class="i field">s_oemEncoding</a> == <b>null</b>)
            {
                <span class="c">// load all available encodings</span>
                <a href="#c4cb03fb01820e43" class="i method">EncodingRegisterProvider</a>();
<span class="k preprocess">#</span><span class="k preprocess">if</span> <span class="i">UNIX</span>
<span class="e">                s_oemEncoding = new UTF8Encoding(false);
</span><span class="k preprocess">#</span><span class="k preprocess">else</span>
                <b>uint</b> <span id="r8 rd" class="r8 r">oemCp</span> = <a href="#8b638890c8d80550" class="t t">NativeMethods</a>.<a href="#ad9dd19046a279a2" class="i method">GetOEMCP</a>();
                <a href="#9713d89229054647" class="i field">s_oemEncoding</a> = <span class="i">Encoding</span>.<span class="i">GetEncoding</span>((<b>int</b>)<span class="r8 r">oemCp</span>);
<span class="k preprocess">#</span><span class="k preprocess">endif</span>
            }
 
            <b>return</b> <a href="#9713d89229054647" class="i field">s_oemEncoding</a>;
        }
 
        <b>private static volatile</b> <span class="i">Encoding</span> <a id="9713d89229054647" href="../R/9713d89229054647.html" target="n" data-glyph="46,1" class="i field">s_oemEncoding</a>;
 
        <b>private static void</b> <a id="c4cb03fb01820e43" href="../R/c4cb03fb01820e43.html" target="n" data-glyph="76,1" class="i method">EncodingRegisterProvider</a>()
        {
            <b>if</b> (<a href="#e0428c24354f6951" class="i field">s_defaultEncoding</a> == <b>null</b> &amp;&amp; <a href="#9713d89229054647" class="i field">s_oemEncoding</a> == <b>null</b>)
            {
                <span class="i">Encoding</span>.<span class="i">RegisterProvider</span>(<span class="i">CodePagesEncodingProvider</span>.<span class="i">Instance</span>);
            }
        }
 
        <span class="k preprocess">#</span><span class="k preprocess">endregion</span> Encoding
 
<span class="k preprocess">#</span><span class="k preprocess">if</span> !<span class="i">UNIX</span>
        <span class="k preprocess">#</span><span class="k preprocess">region</span> Security
 
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Facade to get the SecurityZone information of a file.</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
        <b>internal static</b> <span class="i">SecurityZone</span> <a id="6906f42830096d4c" href="../R/6906f42830096d4c.html" target="n" data-glyph="74,1" class="i method">GetFileSecurityZone</a>(<b>string</b> <span id="r9 rd" class="r9 r">filePath</span>)
        {
            <a href="assert.cs.html#c04955255430d32f" class="t t">Diagnostics</a>.<span class="i">Assert</span>(<span class="i">Path</span>.<span class="i">IsPathRooted</span>(<span class="r9 r">filePath</span>), <span class="s">&quot;Caller makes sure the path is rooted.&quot;</span>);
            <a href="assert.cs.html#c04955255430d32f" class="t t">Diagnostics</a>.<span class="i">Assert</span>(<span class="i">File</span>.<span class="i">Exists</span>(<span class="r9 r">filePath</span>), <span class="s">&quot;Caller makes sure the file exists.&quot;</span>);
            <b>return</b> <a href="#b1d67426ed46d321" class="i method">MapSecurityZone</a>(<span class="r9 r">filePath</span>);
        }
 
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Map the file to SecurityZone.</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> The algorithm is as follows:</span>
        <span class="c">///</span>
        <span class="c">///</span><span class="c"> 1. Alternate data stream &quot;Zone.Identifier&quot; is checked first. If this alternate data stream has content, then the content is parsed to determine the SecurityZone.</span>
        <span class="c">///</span><span class="c"> 2. If the alternate data stream &quot;Zone.Identifier&quot; doesn&#39;t exist, or its content is not expected, then the file path will be analyzed to determine the SecurityZone.</span>
        <span class="c">///</span>
        <span class="c">///</span><span class="c"> For #1, the parsing rules are observed as follows:</span>
        <span class="c">///</span><span class="c">   A. Read content of the data stream line by line. Each line is trimmed.</span>
        <span class="c">///</span><span class="c">   B. Try to match the current line with &#39;^\[ZoneTransfer\]&#39;.</span>
        <span class="c">///</span><span class="c">        - if matching, then do step (#C) starting from the next line</span>
        <span class="c">///</span><span class="c">        - if not matching, then continue to do step (#B) with the next line.</span>
        <span class="c">///</span><span class="c">   C. Try to match the current line with &#39;^ZoneId\s*=\s*(.*)&#39;</span>
        <span class="c">///</span><span class="c">        - if matching, check if the ZoneId is valid. Then return the corresponding SecurityZone if the &#39;ZoneId&#39; is valid, or &#39;NoZone&#39; if invalid.</span>
        <span class="c">///</span><span class="c">        - if not matching, then continue to do step (#C) with the next line.</span>
        <span class="c">///</span><span class="c">   D. Reach EOF, then return &#39;NoZone&#39;.</span>
        <span class="c">///</span><span class="c"> After #1, if the returned SecurityZone is &#39;NoZone&#39;, then proceed with #2. Otherwise, return it as the mapping result.</span>
        <span class="c">///</span>
        <span class="c">///</span><span class="c"> For #2, the analysis rules are observed as follows:</span>
        <span class="c">///</span><span class="c">   A. If the path is a UNC path, then</span>
        <span class="c">///</span><span class="c">       - if the host name of the UNC path is IP address, then mapping it to &quot;Internet&quot; zone.</span>
        <span class="c">///</span><span class="c">       - if the host name of the UNC path has dot (.) in it, then mapping it to &quot;internet&quot; zone.</span>
        <span class="c">///</span><span class="c">       - otherwise, mapping it to &quot;intranet&quot; zone.</span>
        <span class="c">///</span><span class="c">   B. If the path is not UNC path, then get the root drive,</span>
        <span class="c">///</span><span class="c">       - if the drive is CDRom, mapping it to &quot;Untrusted&quot; zone</span>
        <span class="c">///</span><span class="c">       - if the drive is Network, mapping it to &quot;Intranet&quot; zone</span>
        <span class="c">///</span><span class="c">       - otherwise, mapping it to &quot;MyComputer&quot; zone.</span>
        <span class="c">///</span>
        <span class="c">///</span><span class="c"> The above algorithm has two changes comparing to the behavior of &quot;Zone.CreateFromUrl&quot; I observed:</span>
        <span class="c">///</span><span class="c">   (1) If a file downloaded from internet (ZoneId=3) is not on the local machine, &quot;Zone.CreateFromUrl&quot; won&#39;t respect the MOTW.</span>
        <span class="c">///</span><span class="c">       I think it makes more sense for powershell to always check the MOTW first, even for files not on local box.</span>
        <span class="c">///</span><span class="c">   (2) When it&#39;s a UNC path and is actually a loopback (\\127.0.0.1\c$\test.txt), &quot;Zone.CreateFromUrl&quot; returns &quot;Internet&quot;, but</span>
        <span class="c">///</span><span class="c">       the above algorithm changes it to be &quot;MyComputer&quot; because it&#39;s actually the same computer.</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
        <b>private static</b> <span class="i">SecurityZone</span> <a id="b1d67426ed46d321" href="../R/b1d67426ed46d321.html" target="n" data-glyph="76,1" class="i method">MapSecurityZone</a>(<b>string</b> <span id="r10 rd" class="r10 r">filePath</span>)
        {
            <span class="c">// WSL introduces a new filesystem path to access the Linux filesystem from Windows, like &#39;\\wsl$\ubuntu&#39;.</span>
            <span class="c">// If the given file path is such a special case, we consider it&#39;s in &#39;MyComputer&#39; zone.</span>
            <b>if</b> (<span class="r10 r">filePath</span>.<span class="i">StartsWith</span>(<a href="../engine/Utils.cs.html#9185d6ecbaebbec0" class="t t">Utils</a>.<a href="../engine/Utils.cs.html#27ced2dd003c2668" class="i field">WslRootPath</a>, <span class="i">StringComparison</span>.<span class="i">OrdinalIgnoreCase</span>))
            {
                <b>return</b> <span class="i">SecurityZone</span>.<span class="i">MyComputer</span>;
            }
 
            <span class="i">SecurityZone</span> <span id="r11 rd" class="r11 r">reval</span> = <a href="#928e130e42579cdc" class="i method">ReadFromZoneIdentifierDataStream</a>(<span class="r10 r">filePath</span>);
            <b>if</b> (<span class="r11 r">reval</span> != <span class="i">SecurityZone</span>.<span class="i">NoZone</span>)
            {
                <b>return</b> <span class="r11 r">reval</span>;
            }
 
            <span class="c">// If it reaches here, then we either couldn&#39;t get the ZoneId information, or the ZoneId is invalid.</span>
            <span class="c">// In this case, we try to determine the SecurityZone by analyzing the file path.</span>
            <span class="i">Uri</span> <span id="r12 rd" class="r12 r">uri</span> = <b>new</b> <span class="i">Uri</span>(<span class="r10 r">filePath</span>);
            <b>if</b> (<span class="r12 r">uri</span>.<span class="i">IsUnc</span>)
            {
                <b>if</b> (<span class="r12 r">uri</span>.<span class="i">IsLoopback</span>)
                {
                    <b>return</b> <span class="i">SecurityZone</span>.<span class="i">MyComputer</span>;
                }
 
                <b>if</b> (<span class="r12 r">uri</span>.<span class="i">HostNameType</span> == <span class="i">UriHostNameType</span>.<span class="i">IPv4</span> ||
                    <span class="r12 r">uri</span>.<span class="i">HostNameType</span> == <span class="i">UriHostNameType</span>.<span class="i">IPv6</span>)
                {
                    <b>return</b> <span class="i">SecurityZone</span>.<span class="i">Internet</span>;
                }
 
                <span class="c">// This is also an observation of Zone.CreateFromUrl/Zone.SecurityZone. If the host name</span>
                <span class="c">// has &#39;dot&#39; in it, the file will be treated as in Internet security zone. Otherwise, it&#39;s</span>
                <span class="c">// in Intranet security zone.</span>
                <b>string</b> <span id="r13 rd" class="r13 r">hostName</span> = <span class="r12 r">uri</span>.<span class="i">Host</span>;
                <b>return</b> <span class="r13 r">hostName</span>.<span class="i">Contains</span>(<span class="s">&#39;.&#39;</span>) ? <span class="i">SecurityZone</span>.<span class="i">Internet</span> : <span class="i">SecurityZone</span>.<span class="i">Intranet</span>;
            }
 
            <b>string</b> <span id="r14 rd" class="r14 r">root</span> = <span class="i">Path</span>.<span class="i">GetPathRoot</span>(<span class="r10 r">filePath</span>);
            <span class="i">DriveInfo</span> <span id="r15 rd" class="r15 r">drive</span> = <b>new</b> <span class="i">DriveInfo</span>(<span class="r14 r">root</span>);
            <b>switch</b> (<span class="r15 r">drive</span>.<span class="i">DriveType</span>)
            {
                <b>case</b> <span class="i">DriveType</span>.<span class="i">NoRootDirectory</span>:
                <b>case</b> <span class="i">DriveType</span>.<span class="i">Unknown</span>:
                <b>case</b> <span class="i">DriveType</span>.<span class="i">CDRom</span>:
                    <b>return</b> <span class="i">SecurityZone</span>.<span class="i">Untrusted</span>;
                <b>case</b> <span class="i">DriveType</span>.<span class="i">Network</span>:
                    <b>return</b> <span class="i">SecurityZone</span>.<span class="i">Intranet</span>;
                <b>default</b>:
                    <b>return</b> <span class="i">SecurityZone</span>.<span class="i">MyComputer</span>;
            }
        }
 
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Read the &#39;Zone.Identifier&#39; alternate data stream to determin SecurityZone of the file.</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
        <b>private static</b> <span class="i">SecurityZone</span> <a id="928e130e42579cdc" href="../R/928e130e42579cdc.html" target="n" data-glyph="76,1" class="i method">ReadFromZoneIdentifierDataStream</a>(<b>string</b> <span id="r16 rd" class="r16 r">filePath</span>)
        {
            <b>if</b> (!<a href="../namespaces/FileSystemProvider.cs.html#28276e8c322107d7" class="t t">AlternateDataStreamUtilities</a>.<span class="i">TryCreateFileStream</span>(<span class="r16 r">filePath</span>, <span class="s">&quot;Zone.Identifier&quot;</span>, <span class="i">FileMode</span>.<span class="i">Open</span>, <span class="i">FileAccess</span>.<span class="i">Read</span>, <span class="i">FileShare</span>.<span class="i">Read</span>, <b>out</b> <b>var</b> <span id="r17 rd" class="r17 r">zoneDataStream</span>))
            {
                <b>return</b> <span class="i">SecurityZone</span>.<span class="i">NoZone</span>;
            }
 
            <span class="c">// If we successfully get the zone data stream, try to read the ZoneId information</span>
            <b>using</b> (<span class="i">StreamReader</span> <span id="r18 rd" class="r18 r">zoneDataReader</span> = <b>new</b> <span class="i">StreamReader</span>(<span class="r17 r">zoneDataStream</span>, <a href="#0c8a7fc2b80117dd" class="i method">GetDefaultEncoding</a>()))
            {
                <b>string</b> <span id="r19 rd" class="r19 r">line</span> = <b>null</b>;
                <b>bool</b> <span id="r20 rd" class="r20 r">zoneTransferMatched</span> = <b>false</b>;
 
                <span class="c">// After a lot experiments with Zone.CreateFromUrl/Zone.SecurityZone, the way it handles the alternate</span>
                <span class="c">// data stream &#39;Zone.Identifier&#39; is observed as follows:</span>
                <span class="c">//    1. Read content of the data stream line by line. Each line is trimmed.</span>
                <span class="c">//    2. Try to match the current line with &#39;^\[ZoneTransfer\]&#39;.</span>
                <span class="c">//           - if matching, then do step #3 starting from the next line</span>
                <span class="c">//           - if not matching, then continue to do step #2 with the next line.</span>
                <span class="c">//    3. Try to match the current line with &#39;^ZoneId\s*=\s*(.*)&#39;</span>
                <span class="c">//           - if matching, check if the ZoneId is valid. Then return the corresponding SecurityZone if valid, or &#39;NoZone&#39; if invalid.</span>
                <span class="c">//           - if not matching, then continue to do step #3 with the next line.</span>
                <span class="c">//    4. Reach EOF, then return &#39;NoZone&#39;.</span>
                <b>while</b> ((<span class="r19 r">line</span> = <span class="r18 r">zoneDataReader</span>.<span class="i">ReadLine</span>()) != <b>null</b>)
                {
                    <span class="r19 r">line</span> = <span class="r19 r">line</span>.<span class="i">Trim</span>();
                    <b>if</b> (!<span class="r20 r">zoneTransferMatched</span>)
                    {
                        <span class="r20 r">zoneTransferMatched</span> = <span class="i">Regex</span>.<span class="i">IsMatch</span>(<span class="r19 r">line</span>, <span class="s">@&quot;^\[ZoneTransfer\]&quot;</span>, <span class="i">RegexOptions</span>.<span class="i">IgnoreCase</span>);
                    }
                    <b>else</b>
                    {
                        <span class="i">Match</span> <span id="r21 rd" class="r21 r">match</span> = <span class="i">Regex</span>.<span class="i">Match</span>(<span class="r19 r">line</span>, <span class="s">@&quot;^ZoneId\s*=\s*(.*)&quot;</span>, <span class="i">RegexOptions</span>.<span class="i">IgnoreCase</span>);
                        <b>if</b> (!<span class="r21 r">match</span>.<span class="i">Success</span>) { <b>continue</b>; }
 
                        <span class="c">// Match found. Validate ZoneId value.</span>
                        <b>string</b> <span id="r22 rd" class="r22 r">zoneIdRawValue</span> = <span class="r21 r">match</span>.<span class="i">Groups</span>[1].<span class="i">Value</span>;
                        <span class="r21 r">match</span> = <span class="i">Regex</span>.<span class="i">Match</span>(<span class="r22 r">zoneIdRawValue</span>, <span class="s">@&quot;^[+-]?\d+&quot;</span>, <span class="i">RegexOptions</span>.<span class="i">IgnoreCase</span>);
                        <b>if</b> (!<span class="r21 r">match</span>.<span class="i">Success</span>) { <b>return</b> <span class="i">SecurityZone</span>.<span class="i">NoZone</span>; }
 
                        <b>string</b> <span id="r23 rd" class="r23 r">zoneId</span> = <span class="r21 r">match</span>.<span class="i">Groups</span>[0].<span class="i">Value</span>;
                        <span class="i">SecurityZone</span> <span id="r24 rd" class="r24 r">result</span>;
                        <b>return</b> <a href="../engine/LanguagePrimitives.cs.html#6dac09d64da9900c" class="t t">LanguagePrimitives</a>.<span class="i">TryConvertTo</span>(<span class="r23 r">zoneId</span>, <b>out</b> <span class="r24 r">result</span>) ? <span class="r24 r">result</span> : <span class="i">SecurityZone</span>.<span class="i">NoZone</span>;
                    }
                }
            }
 
            <b>return</b> <span class="i">SecurityZone</span>.<span class="i">NoZone</span>;
        }
 
        <span class="k preprocess">#</span><span class="k preprocess">endregion</span> Security
<span class="k preprocess">#</span><span class="k preprocess">endif</span>
 
        <span class="k preprocess">#</span><span class="k preprocess">region</span> Misc
 
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Facade for ManagementDateTimeConverter.ToDmtfDateTime(DateTime)</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
        <b>internal static string</b> <a id="5e40fd3bcfe0a582" href="../R/../../0000000000.html" target="n" data-glyph="74,1" class="i method">ToDmtfDateTime</a>(<span class="i">DateTime</span> <span id="r25 rd" class="r25 r">date</span>)
        {
<span class="k preprocess">#</span><span class="k preprocess">if</span> <span class="i">CORECLR</span>
            <span class="c">// This implementation is copied from ManagementDateTimeConverter.ToDmtfDateTime(DateTime date) with a minor adjustment:</span>
            <span class="c">// Use TimeZoneInfo.Local instead of TimeZone.CurrentTimeZone. System.TimeZone is not in CoreCLR.</span>
            <span class="c">// According to MSDN, CurrentTimeZone property corresponds to the TimeZoneInfo.Local property, and</span>
            <span class="c">// it&#39;s recommended to use TimeZoneInfo.Local whenever possible.</span>
 
            <b>const int</b> <span id="r26 rd" class="r26 r">maxsizeUtcDmtf</span> = 999;
            <b>string</b> <span id="r27 rd" class="r27 r">UtcString</span> = <b>string</b>.<span class="i">Empty</span>;
            <span class="c">// Fill up the UTC field in the DMTF date with the current zones UTC value</span>
            <span class="i">TimeZoneInfo</span> <span id="r28 rd" class="r28 r">curZone</span> = <span class="i">TimeZoneInfo</span>.<span class="i">Local</span>;
            <span class="i">TimeSpan</span> <span id="r29 rd" class="r29 r">tickOffset</span> = <span class="r28 r">curZone</span>.<span class="i">GetUtcOffset</span>(<span class="r25 r">date</span>);
            <b>long</b> <span id="r30 rd" class="r30 r">OffsetMins</span> = (<span class="r29 r">tickOffset</span>.<span class="i">Ticks</span> / <span class="i">TimeSpan</span>.<span class="i">TicksPerMinute</span>);
            <span class="i">IFormatProvider</span> <span id="r31 rd" class="r31 r">frmInt32</span> = (<span class="i">IFormatProvider</span>)<span class="i">CultureInfo</span>.<span class="i">InvariantCulture</span>.<span class="i">GetFormat</span>(<b>typeof</b>(<b>int</b>));
 
            <span class="c">// If the offset is more than that what can be specified in DMTF format, then</span>
            <span class="c">// convert the date to UniversalTime</span>
            <b>if</b> (<span class="i">Math</span>.<span class="i">Abs</span>(<span class="r30 r">OffsetMins</span>) &gt; <span class="r26 r">maxsizeUtcDmtf</span>)
            {
                <span class="r25 r">date</span> = <span class="r25 r">date</span>.<span class="i">ToUniversalTime</span>();
                <span class="r27 r">UtcString</span> = <span class="s">&quot;+000&quot;</span>;
            }
            <b>else</b>
                <b>if</b> ((<span class="r29 r">tickOffset</span>.<span class="i">Ticks</span> &gt;= 0))
            {
                <span class="r27 r">UtcString</span> = <span class="s">&quot;+&quot;</span> + ((<span class="r29 r">tickOffset</span>.<span class="i">Ticks</span> / <span class="i">TimeSpan</span>.<span class="i">TicksPerMinute</span>)).<span class="i">ToString</span>(<span class="r31 r">frmInt32</span>).<span class="i">PadLeft</span>(3, <span class="s">&#39;0&#39;</span>);
            }
            <b>else</b>
            {
                <b>string</b> <span id="r32 rd" class="r32 r">strTemp</span> = <span class="r30 r">OffsetMins</span>.<span class="i">ToString</span>(<span class="r31 r">frmInt32</span>);
                <span class="r27 r">UtcString</span> = <span class="s">&quot;-&quot;</span> + <span class="r32 r">strTemp</span>.<span class="i">Substring</span>(1, <span class="r32 r">strTemp</span>.<span class="i">Length</span> - 1).<span class="i">PadLeft</span>(3, <span class="s">&#39;0&#39;</span>);
            }
 
            <b>string</b> <span id="r33 rd" class="r33 r">dmtfDateTime</span> = <span class="r25 r">date</span>.<span class="i">Year</span>.<span class="i">ToString</span>(<span class="r31 r">frmInt32</span>).<span class="i">PadLeft</span>(4, <span class="s">&#39;0&#39;</span>);
 
            <span class="r33 r">dmtfDateTime</span> += <span class="r25 r">date</span>.<span class="i">Month</span>.<span class="i">ToString</span>(<span class="r31 r">frmInt32</span>).<span class="i">PadLeft</span>(2, <span class="s">&#39;0&#39;</span>);
            <span class="r33 r">dmtfDateTime</span> += <span class="r25 r">date</span>.<span class="i">Day</span>.<span class="i">ToString</span>(<span class="r31 r">frmInt32</span>).<span class="i">PadLeft</span>(2, <span class="s">&#39;0&#39;</span>);
            <span class="r33 r">dmtfDateTime</span> += <span class="r25 r">date</span>.<span class="i">Hour</span>.<span class="i">ToString</span>(<span class="r31 r">frmInt32</span>).<span class="i">PadLeft</span>(2, <span class="s">&#39;0&#39;</span>);
            <span class="r33 r">dmtfDateTime</span> += <span class="r25 r">date</span>.<span class="i">Minute</span>.<span class="i">ToString</span>(<span class="r31 r">frmInt32</span>).<span class="i">PadLeft</span>(2, <span class="s">&#39;0&#39;</span>);
            <span class="r33 r">dmtfDateTime</span> += <span class="r25 r">date</span>.<span class="i">Second</span>.<span class="i">ToString</span>(<span class="r31 r">frmInt32</span>).<span class="i">PadLeft</span>(2, <span class="s">&#39;0&#39;</span>);
            <span class="r33 r">dmtfDateTime</span> += <span class="s">&quot;.&quot;</span>;
 
            <span class="c">// Construct a DateTime with with the precision to Second as same as the passed DateTime and so get</span>
            <span class="c">// the ticks difference so that the microseconds can be calculated</span>
            <span class="i">DateTime</span> <span id="r34 rd" class="r34 r">dtTemp</span> = <b>new</b> <span class="i">DateTime</span>(<span class="r25 r">date</span>.<span class="i">Year</span>, <span class="r25 r">date</span>.<span class="i">Month</span>, <span class="r25 r">date</span>.<span class="i">Day</span>, <span class="r25 r">date</span>.<span class="i">Hour</span>, <span class="r25 r">date</span>.<span class="i">Minute</span>, <span class="r25 r">date</span>.<span class="i">Second</span>, 0);
            <span class="i">Int64</span> <span id="r35 rd" class="r35 r">microsec</span> = ((<span class="r25 r">date</span>.<span class="i">Ticks</span> - <span class="r34 r">dtTemp</span>.<span class="i">Ticks</span>) * 1000) / <span class="i">TimeSpan</span>.<span class="i">TicksPerMillisecond</span>;
 
            <span class="c">// fill the microseconds field</span>
            <b>string</b> <span id="r36 rd" class="r36 r">strMicrosec</span> = <span class="r35 r">microsec</span>.<span class="i">ToString</span>((<span class="i">IFormatProvider</span>)<span class="i">CultureInfo</span>.<span class="i">InvariantCulture</span>.<span class="i">GetFormat</span>(<b>typeof</b>(<span class="i">Int64</span>)));
            <b>if</b> (<span class="r36 r">strMicrosec</span>.<span class="i">Length</span> &gt; 6)
            {
                <span class="r36 r">strMicrosec</span> = <span class="r36 r">strMicrosec</span>.<span class="i">Substring</span>(0, 6);
            }
 
            <span class="r33 r">dmtfDateTime</span> += <span class="r36 r">strMicrosec</span>.<span class="i">PadLeft</span>(6, <span class="s">&#39;0&#39;</span>);
            <span class="c">// adding the UTC offset</span>
            <span class="r33 r">dmtfDateTime</span> += <span class="r27 r">UtcString</span>;
 
            <b>return</b> <span class="r33 r">dmtfDateTime</span>;
<span class="k preprocess">#</span><span class="k preprocess">else</span>
<span class="e">            return ManagementDateTimeConverter.ToDmtfDateTime(date);
</span><span class="k preprocess">#</span><span class="k preprocess">endif</span>
        }
 
        <span class="k preprocess">#</span><span class="k preprocess">endregion</span> Misc
 
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Native methods that are used by facade methods.</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
        <b>private static class</b> <a id="8b638890c8d80550" href="../R/8b638890c8d80550.html" target="n" data-glyph="4,1" class="t t">NativeMethods</a>
        {
            <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
            <span class="c">///</span><span class="c"> Pinvoke for GetOEMCP to get the OEM code page.</span>
            <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
            [<span class="i">DllImport</span>(<a href="PInvokeDllNames.cs.html#6c73838805dd2f2a" class="t t">PinvokeDllNames</a>.<a href="PInvokeDllNames.cs.html#6504110ae69d5211" class="i field">GetOEMCPDllName</a>, <span class="i">SetLastError</span> = <b>false</b>, <span class="i">CharSet</span> = <span class="i">CharSet</span>.<span class="i">Unicode</span>)]
            <b>internal static extern uint</b> <a id="ad9dd19046a279a2" href="../R/ad9dd19046a279a2.html" target="n" data-glyph="74,2" class="i method">GetOEMCP</a>();
        }
    }
}
</pre></td></tr></table></div></body></html>
