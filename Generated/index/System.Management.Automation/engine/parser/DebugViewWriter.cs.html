<!DOCTYPE html>
<html><head><title>DebugViewWriter.cs</title><link rel="stylesheet" href="../../../styles.css"><script src="../../../scripts.js"></script></head>
<body class="cB" onload="i(1224);"><div class="dH">
<table style="width: 100%">
<tr><td>File: <a id="filePath" class="blueLink" href="/#System.Management.Automation/engine/parser/DebugViewWriter.cs" target="_top">engine\parser\DebugViewWriter.cs</a><br/></td><td></td></tr>
<tr><td>Project: <a id="projectPath" class="blueLink" href="/#System.Management.Automation" target="_top">src\System.Management.Automation\System.Management.Automation.csproj</a> (System.Management.Automation)</td></tr>
</table>
</div>
<div class="cz"><table class="tb" cellpadding="0" cellspacing="0"><tr><td valign="top" align="right"><pre id="ln"></pre></td><td valign="top" align="left"><pre id="code">
<span class="c">/* ****************************************************************************
 *
 * Copyright (c) Microsoft Corporation.
 *
 * This source code is subject to terms and conditions of the Microsoft Public License. A
 * copy of the license can be found in the License.html file at the root of this distribution. If
 * you cannot locate the Microsoft Public License, please send an email to
 * dlr@microsoft.com. By using this source code in any fashion, you are agreeing to be bound
 * by the terms of the Microsoft Public License.
 *
 * You must not remove this notice, or any other, from this software.
 *
 *
 * ***************************************************************************/</span>
 
<span class="k preprocess">#</span><span class="k preprocess">if</span> <span class="i">ENABLE_BINDER_DEBUG_LOGGING</span>
<span class="e">
using System.Linq.Expressions;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using System.Reflection;
using System.Globalization;
using System.Diagnostics;
using System.Dynamic;
 
namespace System.Management.Automation.Language {
    [System.Diagnostics.CodeAnalysis.SuppressMessage(&quot;Microsoft.Maintainability&quot;, &quot;CA1506:AvoidExcessiveClassCoupling&quot;)]
    internal sealed class DebugViewWriter : DynamicExpressionVisitor {
        [Flags]
        private enum Flow {
            None,
            Space,
            NewLine,
 
            Break = 0x8000      // newline if column &gt; MaxColumn
        };
 
        private const int Tab = 4;
        private const int MaxColumn = 120;
 
        private TextWriter _out;
        private int _column;
 
        private Stack&lt;int&gt; _stack = new Stack&lt;int&gt;();
        private int _delta;
        private Flow _flow;
 
        // All the unique lambda expressions in the ET, will be used for displaying all
        // the lambda definitions.
        private Queue&lt;LambdaExpression&gt; _lambdas;
 
        // Associate every unique anonymous LambdaExpression in the tree with an integer.
        // The id is used to create a name for the anonymous lambda.
        //
        private Dictionary&lt;LambdaExpression, int&gt; _lambdaIds;
 
        // Associate every unique anonymous parameter or variable in the tree with an integer.
        // The id is used to create a name for the anonymous parameter or variable.
        //
        private Dictionary&lt;ParameterExpression, int&gt; _paramIds;
 
        // Associate every unique anonymous LabelTarget in the tree with an integer.
        // The id is used to create a name for the anonymous LabelTarget.
        //
        private Dictionary&lt;LabelTarget, int&gt; _labelIds;
 
        private DebugViewWriter(TextWriter file) {
            _out = file;
        }
 
        private int Base {
            get {
                return _stack.Count &gt; 0 ? _stack.Peek() : 0;
            }
        }
 
        private int Delta {
            get { return _delta; }
        }
 
        private int Depth {
            get { return Base + Delta; }
        }
 
        private void Indent() {
            _delta += Tab;
        }
 
        private void Dedent() {
            _delta -= Tab;
        }
 
        private void NewLine() {
            _flow = Flow.NewLine;
        }
 
        private static int GetId&lt;T&gt;(T e, ref Dictionary&lt;T, int&gt; ids) {
            if (ids == null) {
                ids = new Dictionary&lt;T, int&gt;();
                ids.Add(e, 1);
                return 1;
            } else {
                int id;
                if (!ids.TryGetValue(e, out id)) {
                    // e is met the first time
                    id = ids.Count + 1;
                    ids.Add(e, id);
                }
 
                return id;
            }
        }
 
        private int GetLambdaId(LambdaExpression le) {
            Debug.Assert(string.IsNullOrEmpty(le.Name));
            return GetId(le, ref _lambdaIds);
        }
 
        private int GetParamId(ParameterExpression p) {
            Debug.Assert(string.IsNullOrEmpty(p.Name));
            return GetId(p, ref _paramIds);
        }
 
        private int GetLabelTargetId(LabelTarget target) {
            Debug.Assert(string.IsNullOrEmpty(target.Name));
            return GetId(target, ref _labelIds);
        }
 
        /// &lt;summary&gt;
        /// Write out the given AST.
        /// &lt;/summary&gt;
        internal static void WriteTo(Expression node, TextWriter writer) {
            Debug.Assert(node != null);
            Debug.Assert(writer != null);
 
            new DebugViewWriter(writer).WriteTo(node);
        }
 
        private void WriteTo(Expression node) {
            var lambda = node as LambdaExpression;
            if (lambda != null) {
                WriteLambda(lambda);
            } else {
                Visit(node);
                Debug.Assert(_stack.Count == 0);
            }
 
            //
            // Output all lambda expression definitions.
            // in the order of their appearances in the tree.
            //
            while (_lambdas != null &amp;&amp; _lambdas.Count &gt; 0) {
                WriteLine();
                WriteLine();
                WriteLambda(_lambdas.Dequeue());
            }
        }
 
</span><span class="k preprocess">#</span><span class="k preprocess">region</span> The printing code
<span class="e">
        private void Out(string s) {
            Out(Flow.None, s, Flow.None);
        }
 
        private void Out(Flow before, string s) {
            Out(before, s, Flow.None);
        }
 
        private void Out(string s, Flow after) {
            Out(Flow.None, s, after);
        }
 
        private void Out(Flow before, string s, Flow after) {
            switch (GetFlow(before)) {
                case Flow.None:
                    break;
                case Flow.Space:
                    Write(&quot; &quot;);
                    break;
                case Flow.NewLine:
                    WriteLine();
                    Write(new string(&#39; &#39;, Depth));
                    break;
            }
 
            Write(s);
            _flow = after;
        }
 
        private void WriteLine() {
            _out.WriteLine();
            _column = 0;
        }
 
        private void Write(string s) {
            _out.Write(s);
            _column += s.Length;
        }
 
        private Flow GetFlow(Flow flow) {
            Flow last;
 
            last = CheckBreak(_flow);
            flow = CheckBreak(flow);
 
            // Get the biggest flow that is requested None &lt; Space &lt; NewLine
            return (Flow)System.Math.Max((int)last, (int)flow);
        }
 
        private Flow CheckBreak(Flow flow) {
            if ((flow &amp; Flow.Break) != 0) {
                if (_column &gt; (MaxColumn + Depth)) {
                    flow = Flow.NewLine;
                } else {
                    flow &amp;= ~Flow.Break;
                }
            }
 
            return flow;
        }
 
</span><span class="k preprocess">#</span><span class="k preprocess">endregion</span>
<span class="e">
</span><span class="k preprocess">#</span><span class="k preprocess">region</span> The AST Output
<span class="e">
        // More proper would be to make this a virtual method on Action
        private static string FormatBinder(CallSiteBinder binder) {
            ConvertBinder convert;
            GetMemberBinder getMember;
            SetMemberBinder setMember;
            DeleteMemberBinder deleteMember;
            GetIndexBinder getIndex;
            SetIndexBinder setIndex;
            DeleteIndexBinder deleteIndex;
            InvokeMemberBinder call;
            InvokeBinder invoke;
            CreateInstanceBinder create;
            UnaryOperationBinder unary;
            BinaryOperationBinder binary;
 
            if ((convert = binder as ConvertBinder) != null) {
                return &quot;Convert &quot; + convert.Type.ToString();
            } else if ((getMember = binder as GetMemberBinder) != null) {
                return &quot;GetMember &quot; + getMember.Name;
            } else if ((setMember = binder as SetMemberBinder) != null) {
                return &quot;SetMember &quot; + setMember.Name;
            } else if ((deleteMember = binder as DeleteMemberBinder) != null) {
                return &quot;DeleteMember &quot; + deleteMember.Name;
            } else if ((getIndex = binder as GetIndexBinder) != null) {
                return &quot;GetIndex&quot;;
            } else if ((setIndex = binder as SetIndexBinder) != null) {
                return &quot;SetIndex&quot;;
            } else if ((deleteIndex = binder as DeleteIndexBinder) != null) {
                return &quot;DeleteIndex&quot;;
            } else if ((call = binder as InvokeMemberBinder) != null) {
                return &quot;Call &quot; + call.Name;
            } else if ((invoke = binder as InvokeBinder) != null) {
                return &quot;Invoke&quot;;
            } else if ((create = binder as CreateInstanceBinder) != null) {
                return &quot;Create&quot;;
            } else if ((unary = binder as UnaryOperationBinder) != null) {
                return &quot;UnaryOperation &quot; + unary.Operation;
            } else if ((binary = binder as BinaryOperationBinder) != null) {
                return &quot;BinaryOperation &quot; + binary.Operation;
            } else {
                return binder.ToString();
            }
        }
 
        private void VisitExpressions&lt;T&gt;(char open, IList&lt;T&gt; expressions) where T : Expression {
            VisitExpressions&lt;T&gt;(open, &#39;,&#39;, expressions);
        }
 
        private void VisitExpressions&lt;T&gt;(char open, char separator, IList&lt;T&gt; expressions) where T : Expression {
            VisitExpressions(open, separator, expressions, e =&gt; Visit(e));
        }
 
        private void VisitDeclarations(IList&lt;ParameterExpression&gt; expressions) {
            VisitExpressions(&#39;(&#39;, &#39;,&#39;, expressions, variable =&gt;
            {
                Out(variable.Type.ToString());
                if (variable.IsByRef) {
                    Out(&quot;&amp;&quot;);
                }
 
                Out(&quot; &quot;);
                VisitParameter(variable);
            });
        }
 
        private void VisitExpressions&lt;T&gt;(char open, char separator, IList&lt;T&gt; expressions, Action&lt;T&gt; visit) {
            Out(open.ToString());
 
            if (expressions != null) {
                Indent();
                bool isFirst = true;
                foreach (T e in expressions) {
                    if (isFirst) {
                        if (open == &#39;{&#39; || expressions.Count &gt; 1) {
                            NewLine();
                        }
 
                        isFirst = false;
                    } else {
                        Out(separator.ToString(), Flow.NewLine);
                    }
 
                    visit(e);
                }
 
                Dedent();
            }
 
            char close;
            switch (open) {
                case &#39;(&#39;: close = &#39;)&#39;; break;
                case &#39;{&#39;: close = &#39;}&#39;; break;
                case &#39;[&#39;: close = &#39;]&#39;; break;
                case &#39;&lt;&#39;: close = &#39;&gt;&#39;; break;
                default:
                close = &#39; &#39;;
                Diagnostics.Assert(false, &quot;Unexpected open brace.&quot;);
                break;
            }
 
            if (open == &#39;{&#39;) {
                NewLine();
            }
 
            Out(close.ToString(), Flow.Break);
        }
 
        protected override Expression VisitDynamic(DynamicExpression node) {
            Out(&quot;.Dynamic&quot;, Flow.Space);
            Out(FormatBinder(node.Binder));
            VisitExpressions(&#39;(&#39;, node.Arguments);
            return node;
        }
 
        [System.Diagnostics.CodeAnalysis.SuppressMessage(&quot;Microsoft.Maintainability&quot;, &quot;CA1502:AvoidExcessiveComplexity&quot;)]
        protected override Expression VisitBinary(BinaryExpression node) {
            if (node.NodeType == ExpressionType.ArrayIndex) {
                ParenthesizedVisit(node, node.Left);
                Out(&quot;[&quot;);
                Visit(node.Right);
                Out(&quot;]&quot;);
            } else {
                bool parenthesizeLeft = NeedsParentheses(node, node.Left);
                bool parenthesizeRight = NeedsParentheses(node, node.Right);
 
                string op;
                bool isChecked = false;
                Flow beforeOp = Flow.Space;
                switch (node.NodeType) {
                    case ExpressionType.Assign: op = &quot;=&quot;; break;
                    case ExpressionType.Equal: op = &quot;==&quot;; break;
                    case ExpressionType.NotEqual: op = &quot;!=&quot;; break;
                    case ExpressionType.AndAlso: op = &quot;&amp;&amp;&quot;; beforeOp = Flow.Break | Flow.Space; break;
                    case ExpressionType.OrElse: op = &quot;||&quot;; beforeOp = Flow.Break | Flow.Space; break;
                    case ExpressionType.GreaterThan: op = &quot;&gt;&quot;; break;
                    case ExpressionType.LessThan: op = &quot;&lt;&quot;; break;
                    case ExpressionType.GreaterThanOrEqual: op = &quot;&gt;=&quot;; break;
                    case ExpressionType.LessThanOrEqual: op = &quot;&lt;=&quot;; break;
                    case ExpressionType.Add: op = &quot;+&quot;; break;
                    case ExpressionType.AddAssign: op = &quot;+=&quot;; break;
                    case ExpressionType.AddAssignChecked: op = &quot;+=&quot;; isChecked = true; break;
                    case ExpressionType.AddChecked: op = &quot;+&quot;; isChecked = true; break;
                    case ExpressionType.Subtract: op = &quot;-&quot;; break;
                    case ExpressionType.SubtractAssign: op = &quot;-=&quot;; break;
                    case ExpressionType.SubtractAssignChecked: op = &quot;-=&quot;; isChecked = true; break;
                    case ExpressionType.SubtractChecked: op = &quot;-&quot;; isChecked = true; break;
                    case ExpressionType.Divide: op = &quot;/&quot;; break;
                    case ExpressionType.DivideAssign: op = &quot;/=&quot;; break;
                    case ExpressionType.Modulo: op = &quot;%&quot;; break;
                    case ExpressionType.ModuloAssign: op = &quot;%=&quot;; break;
                    case ExpressionType.Multiply: op = &quot;*&quot;; break;
                    case ExpressionType.MultiplyAssign: op = &quot;*=&quot;; break;
                    case ExpressionType.MultiplyAssignChecked: op = &quot;*=&quot;; isChecked = true; break;
                    case ExpressionType.MultiplyChecked: op = &quot;*&quot;; isChecked = true; break;
                    case ExpressionType.LeftShift: op = &quot;&lt;&lt;&quot;; break;
                    case ExpressionType.LeftShiftAssign: op = &quot;&lt;&lt;=&quot;; break;
                    case ExpressionType.RightShift: op = &quot;&gt;&gt;&quot;; break;
                    case ExpressionType.RightShiftAssign: op = &quot;&gt;&gt;=&quot;; break;
                    case ExpressionType.And: op = &quot;&amp;&quot;; break;
                    case ExpressionType.AndAssign: op = &quot;&amp;=&quot;; break;
                    case ExpressionType.Or: op = &quot;|&quot;; break;
                    case ExpressionType.OrAssign: op = &quot;|=&quot;; break;
                    case ExpressionType.ExclusiveOr: op = &quot;^&quot;; break;
                    case ExpressionType.ExclusiveOrAssign: op = &quot;^=&quot;; break;
                    case ExpressionType.Power: op = &quot;**&quot;; break;
                    case ExpressionType.PowerAssign: op = &quot;**=&quot;; break;
                    case ExpressionType.Coalesce: op = &quot;??&quot;; break;
 
                    default:
                        throw new InvalidOperationException();
                }
 
                if (parenthesizeLeft) {
                    Out(&quot;(&quot;, Flow.None);
                }
 
                Visit(node.Left);
                if (parenthesizeLeft) {
                    Out(Flow.None, &quot;)&quot;, Flow.Break);
                }
 
                // prepend # to the operator to represent checked op
                if (isChecked) {
                    op = string.Format(
                            CultureInfo.CurrentCulture,
                            &quot;#{0}&quot;,
                            op
                    );
                }
 
                Out(beforeOp, op, Flow.Space | Flow.Break);
 
                if (parenthesizeRight) {
                    Out(&quot;(&quot;, Flow.None);
                }
 
                Visit(node.Right);
                if (parenthesizeRight) {
                    Out(Flow.None, &quot;)&quot;, Flow.Break);
                }
            }
 
            return node;
        }
 
        protected override Expression VisitParameter(ParameterExpression node) {
            // Have &#39;$&#39; for the DebugView of ParameterExpressions
            Out(&quot;$&quot;);
            if (string.IsNullOrEmpty(node.Name)) {
                // If no name if provided, generate a name as $var1, $var2.
                // No guarantee for not having name conflicts with user provided variable names.
                //
                int id = GetParamId(node);
                Out(&quot;var&quot; + id);
            } else {
                Out(GetDisplayName(node.Name));
            }
 
            return node;
        }
 
        protected override Expression VisitLambda&lt;T&gt;(Expression&lt;T&gt; node) {
            Out(
                string.Format(CultureInfo.CurrentCulture,
                    &quot;{0} {1}&lt;{2}&gt;&quot;,
                    &quot;.Lambda&quot;,
                    GetLambdaName(node),
                    node.Type.ToString()
                )
            );
 
            if (_lambdas == null) {
                _lambdas = new Queue&lt;LambdaExpression&gt;();
            }
 
            // N^2 performance, for keeping the order of the lambdas.
            if (!_lambdas.Contains(node)) {
                _lambdas.Enqueue(node);
            }
 
            return node;
        }
 
        private static bool IsSimpleExpression(Expression node) {
            var binary = node as BinaryExpression;
            if (binary != null) {
                return binary.Left is not BinaryExpression &amp;&amp; binary.Right is not BinaryExpression;
            }
 
            return false;
        }
 
        protected override Expression VisitConditional(ConditionalExpression node) {
            if (IsSimpleExpression(node.Test)) {
                Out(&quot;.If (&quot;);
                Visit(node.Test);
                Out(&quot;) {&quot;, Flow.NewLine);
            } else {
                Out(&quot;.If (&quot;, Flow.NewLine);
                Indent();
                Visit(node.Test);
                Dedent();
                Out(Flow.NewLine, &quot;) {&quot;, Flow.NewLine);
            }
 
            Indent();
            Visit(node.IfTrue);
            Dedent();
            Out(Flow.NewLine, &quot;} .Else {&quot;, Flow.NewLine);
            Indent();
            Visit(node.IfFalse);
            Dedent();
            Out(Flow.NewLine, &quot;}&quot;);
            return node;
        }
 
        protected override Expression VisitConstant(ConstantExpression node) {
            object value = node.Value;
 
            if (value == null) {
                Out(&quot;null&quot;);
            } else if ((value is string) &amp;&amp; node.Type == typeof(string)) {
                Out(string.Format(
                    CultureInfo.CurrentCulture,
                    &quot;\&quot;{0}\&quot;&quot;,
                    value));
            } else if ((value is char) &amp;&amp; node.Type == typeof(char)) {
                    Out(string.Format(
                        CultureInfo.CurrentCulture,
                        &quot;&#39;{0}&#39;&quot;,
                        value));
            } else if ((value is int) &amp;&amp; node.Type == typeof(int)
                || (value is bool) &amp;&amp; node.Type == typeof(bool)) {
                Out(value.ToString());
            } else {
                string suffix = GetConstantValueSuffix(node.Type);
                if (suffix != null) {
                    Out(value.ToString());
                    Out(suffix);
                } else {
                    Out(string.Format(
                        CultureInfo.CurrentCulture,
                        &quot;.Constant&lt;{0}&gt;({1})&quot;,
                        node.Type.ToString(),
                        value));
                }
            }
 
            return node;
        }
 
        private static string GetConstantValueSuffix(Type type) {
            if (type == typeof(UInt32)) {
                return &quot;U&quot;;
            }
 
            if (type == typeof(Int64)) {
                return &quot;L&quot;;
            }
 
            if (type == typeof(UInt64)) {
                return &quot;UL&quot;;
            }
 
            if (type == typeof(double)) {
                return &quot;D&quot;;
            }
 
            if (type == typeof(Single)) {
                return &quot;F&quot;;
            }
 
            if (type == typeof(decimal)) {
                return &quot;M&quot;;
            }
 
            return null;
        }
 
        protected override Expression VisitRuntimeVariables(RuntimeVariablesExpression node) {
            Out(&quot;.RuntimeVariables&quot;);
            VisitExpressions(&#39;(&#39;, node.Variables);
            return node;
        }
 
        // Prints &quot;.instanceField&quot; or &quot;declaringType.staticField&quot;
        private void OutMember(Expression node, Expression instance, MemberInfo member) {
            if (instance != null) {
                ParenthesizedVisit(node, instance);
                Out(&quot;.&quot; + member.Name);
            } else {
                // For static members, include the type name
                Out(member.DeclaringType.ToString() + &quot;.&quot; + member.Name);
            }
        }
 
        protected override Expression VisitMember(MemberExpression node) {
            OutMember(node, node.Expression, node.Member);
            return node;
        }
 
        protected override Expression VisitInvocation(InvocationExpression node) {
            Out(&quot;.Invoke &quot;);
            ParenthesizedVisit(node, node.Expression);
            VisitExpressions(&#39;(&#39;, node.Arguments);
            return node;
        }
 
        [System.Diagnostics.CodeAnalysis.SuppressMessage(&quot;Microsoft.Maintainability&quot;, &quot;CA1502:AvoidExcessiveComplexity&quot;)]
        private static bool NeedsParentheses(Expression parent, Expression child) {
            Debug.Assert(parent != null);
            if (child == null) {
                return false;
            }
 
            // Some nodes always have parentheses because of how they are
            // displayed, for example: &quot;.Unbox(obj.Foo)&quot;
            switch (parent.NodeType) {
                case ExpressionType.Increment:
                case ExpressionType.Decrement:
                case ExpressionType.IsTrue:
                case ExpressionType.IsFalse:
                case ExpressionType.Unbox:
                    return true;
            }
 
            int childOpPrec = GetOperatorPrecedence(child);
            int parentOpPrec = GetOperatorPrecedence(parent);
 
            if (childOpPrec == parentOpPrec) {
                // When parent op and child op has the same precedence,
                // we want to be a little conservative to have more clarity.
                // Parentheses are not needed if
                // 1) Both ops are &amp;&amp;, ||, &amp;, |, or ^, all of them are the only
                // op that has the precedence.
                // 2) Parent op is + or *, e.g. x + (y - z) can be simplified to
                // x + y - z.
                // 3) Parent op is -, / or %, and the child is the left operand.
                // In this case, if left and right operand are the same, we don&#39;t
                // remove parenthesis, e.g. (x + y) - (x + y)
                //
                switch (parent.NodeType) {
                    case ExpressionType.AndAlso:
                    case ExpressionType.OrElse:
                    case ExpressionType.And:
                    case ExpressionType.Or:
                    case ExpressionType.ExclusiveOr:
                        // Since these ops are the only ones on their precedence,
                        // the child op must be the same.
                        Debug.Assert(child.NodeType == parent.NodeType);
                        // We remove the parenthesis, e.g. x &amp;&amp; y &amp;&amp; z
                        return false;
                    case ExpressionType.Add:
                    case ExpressionType.AddChecked:
                    case ExpressionType.Multiply:
                    case ExpressionType.MultiplyChecked:
                        return false;
                    case ExpressionType.Subtract:
                    case ExpressionType.SubtractChecked:
                    case ExpressionType.Divide:
                    case ExpressionType.Modulo:
                        BinaryExpression binary = parent as BinaryExpression;
                        Debug.Assert(binary != null);
                        // Need to have parenthesis for the right operand.
                        return child == binary.Right;
                }
 
                return true;
            }
 
            // Special case: negate of a constant needs parentheses, to
            // disambiguate it from a negative constant.
            if (child != null &amp;&amp; child.NodeType == ExpressionType.Constant &amp;&amp;
                (parent.NodeType == ExpressionType.Negate || parent.NodeType == ExpressionType.NegateChecked)) {
                return true;
            }
 
            // If the parent op has higher precedence, need parentheses for the child.
            return childOpPrec &lt; parentOpPrec;
        }
 
        // the greater the higher
        [System.Diagnostics.CodeAnalysis.SuppressMessage(&quot;Microsoft.Maintainability&quot;, &quot;CA1502:AvoidExcessiveComplexity&quot;)]
        private static int GetOperatorPrecedence(Expression node) {
 
            // Roughly matches C# operator precedence, with some additional
            // operators. Also things which are not binary/unary expressions,
            // such as conditional and type testing, don&#39;t use this mechanism.
            switch (node.NodeType) {
                // Assignment
                case ExpressionType.Assign:
                case ExpressionType.ExclusiveOrAssign:
                case ExpressionType.AddAssign:
                case ExpressionType.AddAssignChecked:
                case ExpressionType.SubtractAssign:
                case ExpressionType.SubtractAssignChecked:
                case ExpressionType.DivideAssign:
                case ExpressionType.ModuloAssign:
                case ExpressionType.MultiplyAssign:
                case ExpressionType.MultiplyAssignChecked:
                case ExpressionType.LeftShiftAssign:
                case ExpressionType.RightShiftAssign:
                case ExpressionType.AndAssign:
                case ExpressionType.OrAssign:
                case ExpressionType.PowerAssign:
                case ExpressionType.Coalesce:
                    return 1;
 
                // Conditional (?:) would go here
 
                // Conditional OR
                case ExpressionType.OrElse:
                    return 2;
 
                // Conditional AND
                case ExpressionType.AndAlso:
                    return 3;
 
                // Logical OR
                case ExpressionType.Or:
                    return 4;
 
                // Logical XOR
                case ExpressionType.ExclusiveOr:
                    return 5;
 
                // Logical AND
                case ExpressionType.And:
                    return 6;
 
                // Equality
                case ExpressionType.Equal:
                case ExpressionType.NotEqual:
                    return 7;
 
                // Relational, type testing
                case ExpressionType.GreaterThan:
                case ExpressionType.LessThan:
                case ExpressionType.GreaterThanOrEqual:
                case ExpressionType.LessThanOrEqual:
                case ExpressionType.TypeAs:
                case ExpressionType.TypeIs:
                case ExpressionType.TypeEqual:
                    return 8;
 
                // Shift
                case ExpressionType.LeftShift:
                case ExpressionType.RightShift:
                    return 9;
 
                // Additive
                case ExpressionType.Add:
                case ExpressionType.AddChecked:
                case ExpressionType.Subtract:
                case ExpressionType.SubtractChecked:
                    return 10;
 
                // Multiplicative
                case ExpressionType.Divide:
                case ExpressionType.Modulo:
                case ExpressionType.Multiply:
                case ExpressionType.MultiplyChecked:
                    return 11;
 
                // Unary
                case ExpressionType.Negate:
                case ExpressionType.NegateChecked:
                case ExpressionType.UnaryPlus:
                case ExpressionType.Not:
                case ExpressionType.Convert:
                case ExpressionType.ConvertChecked:
                case ExpressionType.PreIncrementAssign:
                case ExpressionType.PreDecrementAssign:
                case ExpressionType.OnesComplement:
                case ExpressionType.Increment:
                case ExpressionType.Decrement:
                case ExpressionType.IsTrue:
                case ExpressionType.IsFalse:
                case ExpressionType.Unbox:
                case ExpressionType.Throw:
                    return 12;
 
                // Power, which is not in C#
                // But VB/Python/Ruby put it here, above unary.
                case ExpressionType.Power:
                    return 13;
 
                // Primary, which includes all other node types:
                //   member access, calls, indexing, new.
                case ExpressionType.PostIncrementAssign:
                case ExpressionType.PostDecrementAssign:
                default:
                    return 14;
 
                // These aren&#39;t expressions, so never need parentheses:
                //   constants, variables
                case ExpressionType.Constant:
                case ExpressionType.Parameter:
                    return 15;
            }
        }
 
        private void ParenthesizedVisit(Expression parent, Expression nodeToVisit) {
            if (NeedsParentheses(parent, nodeToVisit)) {
                Out(&quot;(&quot;);
                Visit(nodeToVisit);
                Out(&quot;)&quot;);
            } else {
                Visit(nodeToVisit);
            }
        }
 
        protected override Expression VisitMethodCall(MethodCallExpression node) {
            Out(&quot;.Call &quot;);
            if (node.Object != null) {
                ParenthesizedVisit(node, node.Object);
            } else if (node.Method.DeclaringType != null) {
                Out(node.Method.DeclaringType.ToString());
            } else {
                Out(&quot;&lt;UnknownType&gt;&quot;);
            }
 
            Out(&quot;.&quot;);
            Out(node.Method.Name);
            VisitExpressions(&#39;(&#39;, node.Arguments);
            return node;
        }
 
        protected override Expression VisitNewArray(NewArrayExpression node) {
            if (node.NodeType == ExpressionType.NewArrayBounds) {
                // .NewArray MyType[expr1, expr2]
                Out(&quot;.NewArray &quot; + node.Type.GetElementType().ToString());
                VisitExpressions(&#39;[&#39;, node.Expressions);
            } else {
                // .NewArray MyType {expr1, expr2}
 
                Out(&quot;.NewArray &quot; + node.Type.ToString(), Flow.Space);
                VisitExpressions(&#39;{&#39;, node.Expressions);
            }
 
            return node;
        }
 
        protected override Expression VisitNew(NewExpression node) {
            Out(&quot;.New &quot; + node.Type.ToString());
            VisitExpressions(&#39;(&#39;, node.Arguments);
            return node;
        }
 
        protected override ElementInit VisitElementInit(ElementInit node) {
            if (node.Arguments.Count == 1) {
                Visit(node.Arguments[0]);
            } else {
                VisitExpressions(&#39;{&#39;, node.Arguments);
            }
 
            return node;
        }
 
        protected override Expression VisitListInit(ListInitExpression node) {
            Visit(node.NewExpression);
            VisitExpressions(&#39;{&#39;, &#39;,&#39;, node.Initializers, e =&gt; VisitElementInit(e));
            return node;
        }
 
        protected override MemberAssignment VisitMemberAssignment(MemberAssignment assignment) {
            Out(assignment.Member.Name);
            Out(Flow.Space, &quot;=&quot;, Flow.Space);
            Visit(assignment.Expression);
            return assignment;
        }
 
        protected override MemberListBinding VisitMemberListBinding(MemberListBinding binding) {
            Out(binding.Member.Name);
            Out(Flow.Space, &quot;=&quot;, Flow.Space);
            VisitExpressions(&#39;{&#39;, &#39;,&#39;, binding.Initializers, e =&gt; VisitElementInit(e));
            return binding;
        }
 
        protected override MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding) {
            Out(binding.Member.Name);
            Out(Flow.Space, &quot;=&quot;, Flow.Space);
            VisitExpressions(&#39;{&#39;, &#39;,&#39;, binding.Bindings, e =&gt; VisitMemberBinding(e));
            return binding;
        }
 
        protected override Expression VisitMemberInit(MemberInitExpression node) {
            Visit(node.NewExpression);
            VisitExpressions(&#39;{&#39;, &#39;,&#39;, node.Bindings, e =&gt; VisitMemberBinding(e));
            return node;
        }
 
        protected override Expression VisitTypeBinary(TypeBinaryExpression node) {
            ParenthesizedVisit(node, node.Expression);
            switch (node.NodeType) {
                case ExpressionType.TypeIs:
                    Out(Flow.Space, &quot;.Is&quot;, Flow.Space);
                    break;
                case ExpressionType.TypeEqual:
                    Out(Flow.Space, &quot;.TypeEqual&quot;, Flow.Space);
                    break;
            }
 
            Out(node.TypeOperand.ToString());
            return node;
        }
 
        [System.Diagnostics.CodeAnalysis.SuppressMessage(&quot;Microsoft.Maintainability&quot;, &quot;CA1502:AvoidExcessiveComplexity&quot;)]
        protected override Expression VisitUnary(UnaryExpression node) {
            bool parenthesize = NeedsParentheses(node, node.Operand);
 
            switch (node.NodeType) {
                case ExpressionType.Convert:
                    Out(&quot;(&quot; + node.Type.ToString() + &quot;)&quot;);
                    break;
                case ExpressionType.ConvertChecked:
                    Out(&quot;#(&quot; + node.Type.ToString() + &quot;)&quot;);
                    break;
                case ExpressionType.TypeAs:
                    break;
                case ExpressionType.Not:
                    Out(node.Type == typeof(bool) ? &quot;!&quot; : &quot;~&quot;);
                    break;
                case ExpressionType.OnesComplement:
                    Out(&quot;~&quot;);
                    break;
                case ExpressionType.Negate:
                    Out(&quot;-&quot;);
                    break;
                case ExpressionType.NegateChecked:
                    Out(&quot;#-&quot;);
                    break;
                case ExpressionType.UnaryPlus:
                    Out(&quot;+&quot;);
                    break;
                case ExpressionType.ArrayLength:
                    break;
                case ExpressionType.Quote:
                    Out(&quot;&#39;&quot;);
                    break;
                case ExpressionType.Throw:
                    if (node.Operand == null) {
                        Out(&quot;.Rethrow&quot;);
                    } else {
                        Out(&quot;.Throw&quot;, Flow.Space);
                    }
 
                    break;
                case ExpressionType.IsFalse:
                    Out(&quot;.IsFalse&quot;);
                    break;
                case ExpressionType.IsTrue:
                    Out(&quot;.IsTrue&quot;);
                    break;
                case ExpressionType.Decrement:
                    Out(&quot;.Decrement&quot;);
                    break;
                case ExpressionType.Increment:
                    Out(&quot;.Increment&quot;);
                    break;
                case ExpressionType.PreDecrementAssign:
                    Out(&quot;--&quot;);
                    break;
                case ExpressionType.PreIncrementAssign:
                    Out(&quot;++&quot;);
                    break;
                case ExpressionType.Unbox:
                    Out(&quot;.Unbox&quot;);
                    break;
            }
 
            ParenthesizedVisit(node, node.Operand);
 
            switch (node.NodeType) {
                case ExpressionType.TypeAs:
                    Out(Flow.Space, &quot;.As&quot;, Flow.Space | Flow.Break);
                    Out(node.Type.ToString());
                    break;
 
                case ExpressionType.ArrayLength:
                    Out(&quot;.Length&quot;);
                    break;
 
                case ExpressionType.PostDecrementAssign:
                    Out(&quot;--&quot;);
                    break;
 
                case ExpressionType.PostIncrementAssign:
                    Out(&quot;++&quot;);
                    break;
            }
 
            return node;
        }
 
        protected override Expression VisitBlock(BlockExpression node) {
            Out(&quot;.Block&quot;);
 
            // Display &lt;type&gt; if the type of the BlockExpression is different from the
            // last expression&#39;s type in the block.
            if (node.Type != node.Expressions[node.Expressions.Count - 1].Type) {
                Out(string.Format(CultureInfo.CurrentCulture, &quot;&lt;{0}&gt;&quot;, node.Type.ToString()));
            }
 
            VisitDeclarations(node.Variables);
            Out(&quot; &quot;);
            // Use ; to separate expressions in the block
            VisitExpressions(&#39;{&#39;, &#39;;&#39;, node.Expressions);
 
            return node;
        }
 
        protected override Expression VisitDefault(DefaultExpression node) {
            Out(&quot;.Default(&quot; + node.Type.ToString() + &quot;)&quot;);
            return node;
        }
 
        protected override Expression VisitLabel(LabelExpression node) {
            Out(&quot;.Label&quot;, Flow.NewLine);
            Indent();
            Visit(node.DefaultValue);
            Dedent();
            NewLine();
            DumpLabel(node.Target);
            return node;
        }
 
        protected override Expression VisitGoto(GotoExpression node) {
            Out(&quot;.&quot; + node.Kind.ToString(), Flow.Space);
            Out(GetLabelTargetName(node.Target), Flow.Space);
            Out(&quot;{&quot;, Flow.Space);
            Visit(node.Value);
            Out(Flow.Space, &quot;}&quot;);
            return node;
        }
 
        protected override Expression VisitLoop(LoopExpression node) {
            Out(&quot;.Loop&quot;, Flow.Space);
            if (node.ContinueLabel != null) {
                DumpLabel(node.ContinueLabel);
            }
 
            Out(&quot; {&quot;, Flow.NewLine);
            Indent();
            Visit(node.Body);
            Dedent();
            Out(Flow.NewLine, &quot;}&quot;);
            if (node.BreakLabel != null) {
                Out(string.Empty, Flow.NewLine);
                DumpLabel(node.BreakLabel);
            }
 
            return node;
        }
 
        protected override SwitchCase VisitSwitchCase(SwitchCase node) {
            foreach (var test in node.TestValues) {
                Out(&quot;.Case (&quot;);
                Visit(test);
                Out(&quot;):&quot;, Flow.NewLine);
            }
 
            Indent(); Indent();
            Visit(node.Body);
            Dedent(); Dedent();
            NewLine();
            return node;
        }
 
        protected override Expression VisitSwitch(SwitchExpression node) {
            Out(&quot;.Switch &quot;);
            Out(&quot;(&quot;);
            Visit(node.SwitchValue);
            Out(&quot;) {&quot;, Flow.NewLine);
            Visit(node.Cases, VisitSwitchCase);
            if (node.DefaultBody != null) {
                Out(&quot;.Default:&quot;, Flow.NewLine);
                Indent(); Indent();
                Visit(node.DefaultBody);
                Dedent(); Dedent();
                NewLine();
            }
 
            Out(&quot;}&quot;);
            return node;
        }
 
        protected override CatchBlock VisitCatchBlock(CatchBlock node) {
            Out(Flow.NewLine, &quot;} .Catch (&quot; + node.Test.ToString());
            if (node.Variable != null) {
                Out(Flow.Space, string.Empty);
                VisitParameter(node.Variable);
            }
 
            if (node.Filter != null) {
                Out(&quot;) .If (&quot;, Flow.Break);
                Visit(node.Filter);
            }
 
            Out(&quot;) {&quot;, Flow.NewLine);
            Indent();
            Visit(node.Body);
            Dedent();
            return node;
        }
 
        protected override Expression VisitTry(TryExpression node) {
            Out(&quot;.Try {&quot;, Flow.NewLine);
            Indent();
            Visit(node.Body);
            Dedent();
            Visit(node.Handlers, VisitCatchBlock);
            if (node.Finally != null) {
                Out(Flow.NewLine, &quot;} .Finally {&quot;, Flow.NewLine);
                Indent();
                Visit(node.Finally);
                Dedent();
            } else if (node.Fault != null) {
                Out(Flow.NewLine, &quot;} .Fault {&quot;, Flow.NewLine);
                Indent();
                Visit(node.Fault);
                Dedent();
            }
 
            Out(Flow.NewLine, &quot;}&quot;);
            return node;
        }
 
        protected override Expression VisitIndex(IndexExpression node) {
            if (node.Indexer != null) {
                OutMember(node, node.Object, node.Indexer);
            } else {
                ParenthesizedVisit(node, node.Object);
            }
 
            VisitExpressions(&#39;[&#39;, node.Arguments);
            return node;
        }
 
        protected override Expression VisitExtension(Expression node) {
            Out(string.Format(CultureInfo.CurrentCulture, &quot;.Extension&lt;{0}&gt;&quot;, node.GetType().ToString()));
 
            if (node.CanReduce) {
                Out(Flow.Space, &quot;{&quot;, Flow.NewLine);
                Indent();
                Visit(node.Reduce());
                Dedent();
                Out(Flow.NewLine, &quot;}&quot;);
            }
 
            return node;
        }
 
        protected override Expression VisitDebugInfo(DebugInfoExpression node) {
            Out(string.Format(
                CultureInfo.CurrentCulture,
                &quot;.DebugInfo({0}: {1}, {2} - {3}, {4})&quot;,
                node.Document.FileName,
                node.StartLine,
                node.StartColumn,
                node.EndLine,
                node.EndColumn)
            );
            return node;
        }
 
        private void DumpLabel(LabelTarget target) {
            Out(string.Format(CultureInfo.CurrentCulture, &quot;.LabelTarget {0}:&quot;, GetLabelTargetName(target)));
        }
 
        private string GetLabelTargetName(LabelTarget target) {
            if (string.IsNullOrEmpty(target.Name)) {
                // Create the label target name as #Label1, #Label2, etc.
                return string.Format(CultureInfo.CurrentCulture, &quot;#Label{0}&quot;, GetLabelTargetId(target));
            } else {
                return GetDisplayName(target.Name);
            }
        }
 
        private void WriteLambda(LambdaExpression lambda) {
            Out(
                string.Format(
                    CultureInfo.CurrentCulture,
                    &quot;.Lambda {0}&lt;{1}&gt;&quot;,
                    GetLambdaName(lambda),
                    lambda.Type.ToString())
            );
 
            VisitDeclarations(lambda.Parameters);
 
            Out(Flow.Space, &quot;{&quot;, Flow.NewLine);
            Indent();
            Visit(lambda.Body);
            Dedent();
            Out(Flow.NewLine, &quot;}&quot;);
            Debug.Assert(_stack.Count == 0);
        }
 
        private string GetLambdaName(LambdaExpression lambda) {
            if (string.IsNullOrEmpty(lambda.Name)) {
                return &quot;#Lambda&quot; + GetLambdaId(lambda);
            }
 
            return GetDisplayName(lambda.Name);
        }
 
        /// &lt;summary&gt;
        /// Return true if the input string contains any whitespace character.
        /// Otherwise false.
        /// &lt;/summary&gt;
        private static bool ContainsWhiteSpace(string name) {
            foreach (char c in name) {
                if (char.IsWhiteSpace(c)) {
                    return true;
                }
            }
 
            return false;
        }
 
        private static string QuoteName(string name) {
            return string.Format(CultureInfo.CurrentCulture, &quot;&#39;{0}&#39;&quot;, name);
        }
 
        private static string GetDisplayName(string name) {
            if (ContainsWhiteSpace(name)) {
                // if name has whitespaces in it, quote it
                return QuoteName(name);
            } else {
                return name;
            }
        }
 
</span><span class="k preprocess">#</span><span class="k preprocess">endregion</span>
<span class="e">    }
}
</span><span class="k preprocess">#</span><span class="k preprocess">endif</span>
</pre></td></tr></table></div></body></html>
