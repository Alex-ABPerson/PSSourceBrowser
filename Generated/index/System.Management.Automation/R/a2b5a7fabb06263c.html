<!DOCTYPE html>
<html><head><title>TokenKind</title><link rel="stylesheet" href="../../styles.css"/><script src="../../scripts.js"></script></head><body onload="ro();">
<div class="rH">1015 references to TokenKind</div><div class="rA">System.Management.Automation (1015)</div><div class="rG" id="System.Management.Automation"><div class="rF"><div class="rN">DscSupport\CimDSCParser.cs (1)</div>
<a href="../DscSupport/CimDSCParser.cs.html#1710"><b>1710</b>var commandAst = new CommandAst(kwAst.Extent, elements, <i>TokenKind</i>.Unknown, null);</a>
</div>
<div class="rF"><div class="rN">engine\CommandCompletion\CompletionAnalysis.cs (64)</div>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#78"><b>78</b>return token.Kind != <i>TokenKind</i>.NewLine &amp;&amp; token.Kind != <i>TokenKind</i>.EndOfInput;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#246"><b>246</b>errorStatement.Kind.Kind.Equals(<i>TokenKind</i>.Switch) &amp;&amp; errorStatement.Flags.TryGetValue(&quot;file&quot;, out fileConditionTuple))</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#266"><b>266</b>return (errorStatement.Kind.Kind.Equals(<i>TokenKind</i>.Switch) &amp;&amp;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#275"><b>275</b>if (tokenAtCursor.Kind == <i>TokenKind</i>.Minus)</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#279"><b>279</b>else if (tokenAtCursor.Kind == <i>TokenKind</i>.Parameter)</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#288"><b>288</b>private static bool CompleteAgainstStatementFlags(Ast scriptAst, Ast lastAst, Token token, out <i>TokenKind</i> kind)</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#290"><b>290</b>kind = <i>TokenKind</i>.Unknown;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#298"><b>298</b>case <i>TokenKind</i>.Switch:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#299"><b>299</b>kind = <i>TokenKind</i>.Switch;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#308"><b>308</b>if (token != null &amp;&amp; token.Kind == <i>TokenKind</i>.Minus &amp;&amp; scriptBlockAst != null)</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#327"><b>327</b>case <i>TokenKind</i>.Switch:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#334"><b>334</b>kind = <i>TokenKind</i>.Switch;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#409"><b>409</b>case <i>TokenKind</i>.Variable:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#410"><b>410</b>case <i>TokenKind</i>.SplattedVariable:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#415"><b>415</b>case <i>TokenKind</i>.Multiply:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#416"><b>416</b>case <i>TokenKind</i>.Generic:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#417"><b>417</b>case <i>TokenKind</i>.MinusMinus: // for native commands &#39;--&#39;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#418"><b>418</b>case <i>TokenKind</i>.Identifier:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#422"><b>422</b>case <i>TokenKind</i>.Parameter:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#435"><b>435</b><i>TokenKind</i> statementKind;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#464"><b>464</b>case <i>TokenKind</i>.Dot:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#465"><b>465</b>case <i>TokenKind</i>.ColonColon:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#466"><b>466</b>case <i>TokenKind</i>.QuestionDot:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#469"><b>469</b>result = CompletionCompleters.CompleteMember(completionContext, @static: tokenAtCursor.Kind == <i>TokenKind</i>.ColonColon);</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#472"><b>472</b>case <i>TokenKind</i>.Comment:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#481"><b>481</b>case <i>TokenKind</i>.StringExpandable:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#482"><b>482</b>case <i>TokenKind</i>.StringLiteral:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#497"><b>497</b>case <i>TokenKind</i>.RBracket:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#514"><b>514</b>let completionText = <i>TokenKind</i>.ColonColon.Text() + entry.CompletionText</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#521"><b>521</b>case <i>TokenKind</i>.Comma:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#554"><b>554</b>case <i>TokenKind</i>.AtCurly:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#561"><b>561</b>case <i>TokenKind</i>.Semi:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#572"><b>572</b>case <i>TokenKind</i>.Number:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#597"><b>597</b>case <i>TokenKind</i>.Redirection:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#609"><b>609</b>case <i>TokenKind</i>.Minus:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#627"><b>627</b>case <i>TokenKind</i>.DynamicKeyword:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#638"><b>638</b>case <i>TokenKind</i>.Equals:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#639"><b>639</b>case <i>TokenKind</i>.AtParen:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#640"><b>640</b>case <i>TokenKind</i>.LParen:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#728"><b>728</b>isLineContinuationBeforeCursor = completionContext.TokenBeforeCursor.Kind == <i>TokenKind</i>.LineContinuation;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#780"><b>780</b>if ((tokenAtCursor != null &amp;&amp; tokenAtCursor.Kind == <i>TokenKind</i>.LineContinuation) ||</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#781"><b>781</b>(tokenBeforeCursor != null &amp;&amp; tokenBeforeCursor.Kind == <i>TokenKind</i>.LineContinuation))</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#828"><b>828</b>case <i>TokenKind</i>.Equals:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#829"><b>829</b>case <i>TokenKind</i>.Comma:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#830"><b>830</b>case <i>TokenKind</i>.AtParen:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#831"><b>831</b>case <i>TokenKind</i>.LParen:</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#958"><b>958</b>completionContext.TokenAtCursor.Kind != <i>TokenKind</i>.RCurly)</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#1304"><b>1304</b>if (completionContext.TokenAtCursor != null &amp;&amp; completionContext.TokenAtCursor.Kind != <i>TokenKind</i>.Equals)</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#1590"><b>1590</b>completionText = <i>TokenKind</i>.DollarParen.Text() + completionText + <i>TokenKind</i>.RParen.Text();</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#1594"><b>1594</b>completionText = <i>TokenKind</i>.DollarParen.Text() + completionText;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#1968"><b>1968</b><i>TokenKind</i> memberOperator = <i>TokenKind</i>.Unknown;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#1979"><b>1979</b>if (tokenAtCursorText.Equals(<i>TokenKind</i>.Dot.Text(), StringComparison.Ordinal))</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#1981"><b>1981</b>memberOperator = <i>TokenKind</i>.Dot;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#1984"><b>1984</b>else if (tokenAtCursorText.Equals(<i>TokenKind</i>.ColonColon.Text(), StringComparison.Ordinal))</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#1986"><b>1986</b>memberOperator = <i>TokenKind</i>.ColonColon;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#1989"><b>1989</b>else if (tokenAtCursor.Kind.Equals(<i>TokenKind</i>.Multiply) &amp;&amp; lastAst is BinaryExpressionAst)</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#1996"><b>1996</b>if (memberExpressionAst != null &amp;&amp; binaryExpressionAst.Operator == <i>TokenKind</i>.Multiply &amp;&amp;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#2000"><b>2000</b>memberOperator = isStatic ? <i>TokenKind</i>.ColonColon : <i>TokenKind</i>.Dot;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#2021"><b>2021</b>result = CompletionCompleters.CompleteMember(completionContext, @static: (isStatic || memberOperator == <i>TokenKind</i>.ColonColon));</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#2028"><b>2028</b>if (!isWildcard &amp;&amp; memberOperator != <i>TokenKind</i>.Unknown)</a>
</div>
<div class="rF"><div class="rN">engine\CommandCompletion\CompletionCompleters.cs (12)</div>
<a href="../engine/CommandCompletion/CompletionCompleters.cs.html#211"><b>211</b>= new HashSet&lt;string&gt;(StringComparer.OrdinalIgnoreCase) { nameof(<i>TokenKind</i>.InlineScript), nameof(<i>TokenKind</i>.Configuration) };</a>
<a href="../engine/CommandCompletion/CompletionCompleters.cs.html#1161"><b>1161</b>commandAst.InvocationOperator != <i>TokenKind</i>.Unknown &amp;&amp;</a>
<a href="../engine/CommandCompletion/CompletionCompleters.cs.html#1213"><b>1213</b>string prefix = string.Concat(<i>TokenKind</i>.LParen.Text(), input.AsSpan(0, fakeReplacementIndex));</a>
<a href="../engine/CommandCompletion/CompletionCompleters.cs.html#1218"><b>1218</b>completionText += <i>TokenKind</i>.RParen.Text();</a>
<a href="../engine/CommandCompletion/CompletionCompleters.cs.html#1262"><b>1262</b>if (commandAst.InvocationOperator != <i>TokenKind</i>.Unknown &amp;&amp; fileName.IndexOfAny(Utils.Separators.Directory) == 0 &amp;&amp;</a>
<a href="../engine/CommandCompletion/CompletionCompleters.cs.html#5395"><b>5395</b>if (context.TokenAtCursor.Kind != <i>TokenKind</i>.Comment)</a>
<a href="../engine/CommandCompletion/CompletionCompleters.cs.html#5596"><b>5596</b>else if (lastAst.Parent is BinaryExpressionAst &amp;&amp; context.TokenAtCursor.Kind.Equals(<i>TokenKind</i>.Multiply))</a>
<a href="../engine/CommandCompletion/CompletionCompleters.cs.html#6672"><b>6672</b>internal static List&lt;CompletionResult&gt; CompleteStatementFlags(<i>TokenKind</i> kind, string wordToComplete)</a>
<a href="../engine/CommandCompletion/CompletionCompleters.cs.html#6676"><b>6676</b>case <i>TokenKind</i>.Switch:</a>
<a href="../engine/CommandCompletion/CompletionCompleters.cs.html#7323"><b>7323</b>((!defaultChoice &amp;&amp; parent.InvocationOperator == <i>TokenKind</i>.Unknown) ||</a>
<a href="../engine/CommandCompletion/CompletionCompleters.cs.html#7324"><b>7324</b>(defaultChoice &amp;&amp; parent.InvocationOperator != <i>TokenKind</i>.Unknown)))</a>
</div>
<div class="rF"><div class="rN">engine\CommandCompletion\PseudoParameterBinder.cs (1)</div>
<a href="../engine/CommandCompletion/PseudoParameterBinder.cs.html#1191"><b>1191</b>bool dotSource = _commandAst.InvocationOperator == <i>TokenKind</i>.Dot;</a>
</div>
<div class="rF"><div class="rN">engine\InternalCommands.cs (113)</div>
<a href="../engine/InternalCommands.cs.html#1421"><b>1421</b>private <i>TokenKind</i> _binaryOperator = <i>TokenKind</i>.Ieq;</a>
<a href="../engine/InternalCommands.cs.html#1437"><b>1437</b>return _binaryOperator == <i>TokenKind</i>.Ieq;</a>
<a href="../engine/InternalCommands.cs.html#1442"><b>1442</b>_binaryOperator = <i>TokenKind</i>.Ieq;</a>
<a href="../engine/InternalCommands.cs.html#1455"><b>1455</b>return _binaryOperator == <i>TokenKind</i>.Ceq;</a>
<a href="../engine/InternalCommands.cs.html#1460"><b>1460</b>_binaryOperator = <i>TokenKind</i>.Ceq;</a>
<a href="../engine/InternalCommands.cs.html#1473"><b>1473</b>return _binaryOperator == <i>TokenKind</i>.Ine;</a>
<a href="../engine/InternalCommands.cs.html#1478"><b>1478</b>_binaryOperator = <i>TokenKind</i>.Ine;</a>
<a href="../engine/InternalCommands.cs.html#1490"><b>1490</b>return _binaryOperator == <i>TokenKind</i>.Cne;</a>
<a href="../engine/InternalCommands.cs.html#1495"><b>1495</b>_binaryOperator = <i>TokenKind</i>.Cne;</a>
<a href="../engine/InternalCommands.cs.html#1508"><b>1508</b>return _binaryOperator == <i>TokenKind</i>.Igt;</a>
<a href="../engine/InternalCommands.cs.html#1513"><b>1513</b>_binaryOperator = <i>TokenKind</i>.Igt;</a>
<a href="../engine/InternalCommands.cs.html#1525"><b>1525</b>return _binaryOperator == <i>TokenKind</i>.Cgt;</a>
<a href="../engine/InternalCommands.cs.html#1530"><b>1530</b>_binaryOperator = <i>TokenKind</i>.Cgt;</a>
<a href="../engine/InternalCommands.cs.html#1543"><b>1543</b>return _binaryOperator == <i>TokenKind</i>.Ilt;</a>
<a href="../engine/InternalCommands.cs.html#1548"><b>1548</b>_binaryOperator = <i>TokenKind</i>.Ilt;</a>
<a href="../engine/InternalCommands.cs.html#1560"><b>1560</b>return _binaryOperator == <i>TokenKind</i>.Clt;</a>
<a href="../engine/InternalCommands.cs.html#1565"><b>1565</b>_binaryOperator = <i>TokenKind</i>.Clt;</a>
<a href="../engine/InternalCommands.cs.html#1578"><b>1578</b>return _binaryOperator == <i>TokenKind</i>.Ige;</a>
<a href="../engine/InternalCommands.cs.html#1583"><b>1583</b>_binaryOperator = <i>TokenKind</i>.Ige;</a>
<a href="../engine/InternalCommands.cs.html#1595"><b>1595</b>return _binaryOperator == <i>TokenKind</i>.Cge;</a>
<a href="../engine/InternalCommands.cs.html#1600"><b>1600</b>_binaryOperator = <i>TokenKind</i>.Cge;</a>
<a href="../engine/InternalCommands.cs.html#1613"><b>1613</b>return _binaryOperator == <i>TokenKind</i>.Ile;</a>
<a href="../engine/InternalCommands.cs.html#1618"><b>1618</b>_binaryOperator = <i>TokenKind</i>.Ile;</a>
<a href="../engine/InternalCommands.cs.html#1630"><b>1630</b>return _binaryOperator == <i>TokenKind</i>.Cle;</a>
<a href="../engine/InternalCommands.cs.html#1635"><b>1635</b>_binaryOperator = <i>TokenKind</i>.Cle;</a>
<a href="../engine/InternalCommands.cs.html#1648"><b>1648</b>return _binaryOperator == <i>TokenKind</i>.Ilike;</a>
<a href="../engine/InternalCommands.cs.html#1653"><b>1653</b>_binaryOperator = <i>TokenKind</i>.Ilike;</a>
<a href="../engine/InternalCommands.cs.html#1665"><b>1665</b>return _binaryOperator == <i>TokenKind</i>.Clike;</a>
<a href="../engine/InternalCommands.cs.html#1670"><b>1670</b>_binaryOperator = <i>TokenKind</i>.Clike;</a>
<a href="../engine/InternalCommands.cs.html#1688"><b>1688</b>_binaryOperator = <i>TokenKind</i>.Inotlike;</a>
<a href="../engine/InternalCommands.cs.html#1700"><b>1700</b>return _binaryOperator == <i>TokenKind</i>.Cnotlike;</a>
<a href="../engine/InternalCommands.cs.html#1705"><b>1705</b>_binaryOperator = <i>TokenKind</i>.Cnotlike;</a>
<a href="../engine/InternalCommands.cs.html#1718"><b>1718</b>return _binaryOperator == <i>TokenKind</i>.Imatch;</a>
<a href="../engine/InternalCommands.cs.html#1723"><b>1723</b>_binaryOperator = <i>TokenKind</i>.Imatch;</a>
<a href="../engine/InternalCommands.cs.html#1735"><b>1735</b>return _binaryOperator == <i>TokenKind</i>.Cmatch;</a>
<a href="../engine/InternalCommands.cs.html#1740"><b>1740</b>_binaryOperator = <i>TokenKind</i>.Cmatch;</a>
<a href="../engine/InternalCommands.cs.html#1753"><b>1753</b>return _binaryOperator == <i>TokenKind</i>.Inotmatch;</a>
<a href="../engine/InternalCommands.cs.html#1758"><b>1758</b>_binaryOperator = <i>TokenKind</i>.Inotmatch;</a>
<a href="../engine/InternalCommands.cs.html#1770"><b>1770</b>return _binaryOperator == <i>TokenKind</i>.Cnotmatch;</a>
<a href="../engine/InternalCommands.cs.html#1775"><b>1775</b>_binaryOperator = <i>TokenKind</i>.Cnotmatch;</a>
<a href="../engine/InternalCommands.cs.html#1788"><b>1788</b>return _binaryOperator == <i>TokenKind</i>.Icontains;</a>
<a href="../engine/InternalCommands.cs.html#1793"><b>1793</b>_binaryOperator = <i>TokenKind</i>.Icontains;</a>
<a href="../engine/InternalCommands.cs.html#1805"><b>1805</b>return _binaryOperator == <i>TokenKind</i>.Ccontains;</a>
<a href="../engine/InternalCommands.cs.html#1810"><b>1810</b>_binaryOperator = <i>TokenKind</i>.Ccontains;</a>
<a href="../engine/InternalCommands.cs.html#1823"><b>1823</b>return _binaryOperator == <i>TokenKind</i>.Inotcontains;</a>
<a href="../engine/InternalCommands.cs.html#1828"><b>1828</b>_binaryOperator = <i>TokenKind</i>.Inotcontains;</a>
<a href="../engine/InternalCommands.cs.html#1840"><b>1840</b>return _binaryOperator == <i>TokenKind</i>.Cnotcontains;</a>
<a href="../engine/InternalCommands.cs.html#1845"><b>1845</b>_binaryOperator = <i>TokenKind</i>.Cnotcontains;</a>
<a href="../engine/InternalCommands.cs.html#1858"><b>1858</b>return _binaryOperator == <i>TokenKind</i>.In;</a>
<a href="../engine/InternalCommands.cs.html#1863"><b>1863</b>_binaryOperator = <i>TokenKind</i>.In;</a>
<a href="../engine/InternalCommands.cs.html#1875"><b>1875</b>return _binaryOperator == <i>TokenKind</i>.Cin;</a>
<a href="../engine/InternalCommands.cs.html#1880"><b>1880</b>_binaryOperator = <i>TokenKind</i>.Cin;</a>
<a href="../engine/InternalCommands.cs.html#1893"><b>1893</b>return _binaryOperator == <i>TokenKind</i>.Inotin;</a>
<a href="../engine/InternalCommands.cs.html#1898"><b>1898</b>_binaryOperator = <i>TokenKind</i>.Inotin;</a>
<a href="../engine/InternalCommands.cs.html#1910"><b>1910</b>return _binaryOperator == <i>TokenKind</i>.Cnotin;</a>
<a href="../engine/InternalCommands.cs.html#1915"><b>1915</b>_binaryOperator = <i>TokenKind</i>.Cnotin;</a>
<a href="../engine/InternalCommands.cs.html#1927"><b>1927</b>return _binaryOperator == <i>TokenKind</i>.Is;</a>
<a href="../engine/InternalCommands.cs.html#1932"><b>1932</b>_binaryOperator = <i>TokenKind</i>.Is;</a>
<a href="../engine/InternalCommands.cs.html#1944"><b>1944</b>return _binaryOperator == <i>TokenKind</i>.IsNot;</a>
<a href="../engine/InternalCommands.cs.html#1949"><b>1949</b>_binaryOperator = <i>TokenKind</i>.IsNot;</a>
<a href="../engine/InternalCommands.cs.html#1961"><b>1961</b>return _binaryOperator == <i>TokenKind</i>.Not;</a>
<a href="../engine/InternalCommands.cs.html#1966"><b>1966</b>_binaryOperator = <i>TokenKind</i>.Not;</a>
<a href="../engine/InternalCommands.cs.html#2024"><b>2024</b>var wildcardOptions = _binaryOperator == <i>TokenKind</i>.Ilike || _binaryOperator == <i>TokenKind</i>.Inotlike</a>
<a href="../engine/InternalCommands.cs.html#2040"><b>2040</b>case <i>TokenKind</i>.Ieq:</a>
<a href="../engine/InternalCommands.cs.html#2051"><b>2051</b>case <i>TokenKind</i>.Ceq:</a>
<a href="../engine/InternalCommands.cs.html#2054"><b>2054</b>case <i>TokenKind</i>.Ine:</a>
<a href="../engine/InternalCommands.cs.html#2057"><b>2057</b>case <i>TokenKind</i>.Cne:</a>
<a href="../engine/InternalCommands.cs.html#2060"><b>2060</b>case <i>TokenKind</i>.Igt:</a>
<a href="../engine/InternalCommands.cs.html#2063"><b>2063</b>case <i>TokenKind</i>.Cgt:</a>
<a href="../engine/InternalCommands.cs.html#2066"><b>2066</b>case <i>TokenKind</i>.Ilt:</a>
<a href="../engine/InternalCommands.cs.html#2069"><b>2069</b>case <i>TokenKind</i>.Clt:</a>
<a href="../engine/InternalCommands.cs.html#2072"><b>2072</b>case <i>TokenKind</i>.Ige:</a>
<a href="../engine/InternalCommands.cs.html#2075"><b>2075</b>case <i>TokenKind</i>.Cge:</a>
<a href="../engine/InternalCommands.cs.html#2078"><b>2078</b>case <i>TokenKind</i>.Ile:</a>
<a href="../engine/InternalCommands.cs.html#2081"><b>2081</b>case <i>TokenKind</i>.Cle:</a>
<a href="../engine/InternalCommands.cs.html#2084"><b>2084</b>case <i>TokenKind</i>.Ilike:</a>
<a href="../engine/InternalCommands.cs.html#2088"><b>2088</b>case <i>TokenKind</i>.Clike:</a>
<a href="../engine/InternalCommands.cs.html#2092"><b>2092</b>case <i>TokenKind</i>.Inotlike:</a>
<a href="../engine/InternalCommands.cs.html#2096"><b>2096</b>case <i>TokenKind</i>.Cnotlike:</a>
<a href="../engine/InternalCommands.cs.html#2100"><b>2100</b>case <i>TokenKind</i>.Imatch:</a>
<a href="../engine/InternalCommands.cs.html#2105"><b>2105</b>case <i>TokenKind</i>.Cmatch:</a>
<a href="../engine/InternalCommands.cs.html#2110"><b>2110</b>case <i>TokenKind</i>.Inotmatch:</a>
<a href="../engine/InternalCommands.cs.html#2115"><b>2115</b>case <i>TokenKind</i>.Cnotmatch:</a>
<a href="../engine/InternalCommands.cs.html#2120"><b>2120</b>case <i>TokenKind</i>.Not:</a>
<a href="../engine/InternalCommands.cs.html#2126"><b>2126</b>case <i>TokenKind</i>.Icontains:</a>
<a href="../engine/InternalCommands.cs.html#2127"><b>2127</b>case <i>TokenKind</i>.Inotcontains:</a>
<a href="../engine/InternalCommands.cs.html#2128"><b>2128</b>case <i>TokenKind</i>.In:</a>
<a href="../engine/InternalCommands.cs.html#2129"><b>2129</b>case <i>TokenKind</i>.Inotin:</a>
<a href="../engine/InternalCommands.cs.html#2134"><b>2134</b>case <i>TokenKind</i>.Icontains:</a>
<a href="../engine/InternalCommands.cs.html#2138"><b>2138</b>case <i>TokenKind</i>.Inotcontains:</a>
<a href="../engine/InternalCommands.cs.html#2142"><b>2142</b>case <i>TokenKind</i>.In:</a>
<a href="../engine/InternalCommands.cs.html#2146"><b>2146</b>case <i>TokenKind</i>.Inotin:</a>
<a href="../engine/InternalCommands.cs.html#2154"><b>2154</b>case <i>TokenKind</i>.Ccontains:</a>
<a href="../engine/InternalCommands.cs.html#2155"><b>2155</b>case <i>TokenKind</i>.Cnotcontains:</a>
<a href="../engine/InternalCommands.cs.html#2156"><b>2156</b>case <i>TokenKind</i>.Cin:</a>
<a href="../engine/InternalCommands.cs.html#2157"><b>2157</b>case <i>TokenKind</i>.Cnotin:</a>
<a href="../engine/InternalCommands.cs.html#2162"><b>2162</b>case <i>TokenKind</i>.Ccontains:</a>
<a href="../engine/InternalCommands.cs.html#2166"><b>2166</b>case <i>TokenKind</i>.Cnotcontains:</a>
<a href="../engine/InternalCommands.cs.html#2170"><b>2170</b>case <i>TokenKind</i>.Cin:</a>
<a href="../engine/InternalCommands.cs.html#2174"><b>2174</b>case <i>TokenKind</i>.Cnotin:</a>
<a href="../engine/InternalCommands.cs.html#2182"><b>2182</b>case <i>TokenKind</i>.Is:</a>
<a href="../engine/InternalCommands.cs.html#2185"><b>2185</b>case <i>TokenKind</i>.IsNot:</a>
<a href="../engine/InternalCommands.cs.html#2195"><b>2195</b>case <i>TokenKind</i>.Ilike:</a>
<a href="../engine/InternalCommands.cs.html#2196"><b>2196</b>case <i>TokenKind</i>.Clike:</a>
<a href="../engine/InternalCommands.cs.html#2197"><b>2197</b>case <i>TokenKind</i>.Inotlike:</a>
<a href="../engine/InternalCommands.cs.html#2198"><b>2198</b>case <i>TokenKind</i>.Cnotlike:</a>
<a href="../engine/InternalCommands.cs.html#2202"><b>2202</b>case <i>TokenKind</i>.Is:</a>
<a href="../engine/InternalCommands.cs.html#2203"><b>2203</b>case <i>TokenKind</i>.IsNot:</a>
<a href="../engine/InternalCommands.cs.html#2256"><b>2256</b>if (_valueNotSpecified &amp;&amp; ((_binaryOperator != <i>TokenKind</i>.Ieq &amp;&amp; _binaryOperator != <i>TokenKind</i>.Not) || !_forceBooleanEvaluation))</a>
<a href="../engine/InternalCommands.cs.html#2269"><b>2269</b>if (!_valueNotSpecified &amp;&amp; (_binaryOperator == <i>TokenKind</i>.Ieq &amp;&amp; _forceBooleanEvaluation))</a>
</div>
<div class="rF"><div class="rN">engine\lang\parserutils.cs (5)</div>
<a href="../engine/lang/parserutils.cs.html#1154"><b>1154</b>internal static object LikeOperator(ExecutionContext context, IScriptExtent errorPosition, object lval, object rval, <i>TokenKind</i> @operator)</a>
<a href="../engine/lang/parserutils.cs.html#1159"><b>1159</b>var ignoreCase = @operator == <i>TokenKind</i>.Ilike || @operator == <i>TokenKind</i>.Inotlike;</a>
<a href="../engine/lang/parserutils.cs.html#1164"><b>1164</b>bool notLike = @operator == <i>TokenKind</i>.Inotlike || @operator == <i>TokenKind</i>.Cnotlike;</a>
</div>
<div class="rF"><div class="rN">engine\Modules\ModuleCmdletBase.cs (1)</div>
<a href="../engine/Modules/ModuleCmdletBase.cs.html#6037"><b>6037</b>return (cmdAst?.InvocationOperator == <i>TokenKind</i>.Dot);</a>
</div>
<div class="rF"><div class="rN">engine\Modules\ScriptAnalysis.cs (1)</div>
<a href="../engine/Modules/ScriptAnalysis.cs.html#290"><b>290</b>if (commandAst.InvocationOperator == <i>TokenKind</i>.Dot)</a>
</div>
<div class="rF"><div class="rN">engine\parser\ast.cs (55)</div>
<a href="../engine/parser/ast.cs.html#337"><b>337</b>string.Equals(<i>TokenKind</i>.InlineScript.Text(), commandAst.GetCommandName(), StringComparison.OrdinalIgnoreCase) &amp;&amp;</a>
<a href="../engine/parser/ast.cs.html#1060"><b>1060</b>this.ProcessBlock = new NamedBlockAst(statements.Extent, <i>TokenKind</i>.Process, statements, true);</a>
<a href="../engine/parser/ast.cs.html#1065"><b>1065</b>this.EndBlock = new NamedBlockAst(statements.Extent, <i>TokenKind</i>.End, statements, true);</a>
<a href="../engine/parser/ast.cs.html#1760"><b>1760</b>/// &lt;item&gt;&lt;see cref=&quot;<i>TokenKind</i>.Begin&quot;/&gt;&lt;/item&gt;</a>
<a href="../engine/parser/ast.cs.html#1761"><b>1761</b>/// &lt;item&gt;&lt;see cref=&quot;<i>TokenKind</i>.Process&quot;/&gt;&lt;/item&gt;</a>
<a href="../engine/parser/ast.cs.html#1762"><b>1762</b>/// &lt;item&gt;&lt;see cref=&quot;<i>TokenKind</i>.End&quot;/&gt;&lt;/item&gt;</a>
<a href="../engine/parser/ast.cs.html#1763"><b>1763</b>/// &lt;item&gt;&lt;see cref=&quot;<i>TokenKind</i>.Dynamicparam&quot;/&gt;&lt;/item&gt;</a>
<a href="../engine/parser/ast.cs.html#1774"><b>1774</b>/// &lt;see cref=&quot;<i>TokenKind</i>.Process&quot;/&gt; nor &lt;see cref=&quot;<i>TokenKind</i>.End&quot;/&gt;.</a>
<a href="../engine/parser/ast.cs.html#1776"><b>1776</b>public NamedBlockAst(IScriptExtent extent, <i>TokenKind</i> blockName, StatementBlockAst statementBlock, bool unnamed)</a>
<a href="../engine/parser/ast.cs.html#1782"><b>1782</b>|| (unnamed &amp;&amp; (blockName == <i>TokenKind</i>.Begin || blockName == <i>TokenKind</i>.Dynamicparam)))</a>
<a href="../engine/parser/ast.cs.html#1837"><b>1837</b>/// &lt;item&gt;&lt;see cref=&quot;<i>TokenKind</i>.Begin&quot;/&gt;&lt;/item&gt;</a>
<a href="../engine/parser/ast.cs.html#1838"><b>1838</b>/// &lt;item&gt;&lt;see cref=&quot;<i>TokenKind</i>.Process&quot;/&gt;&lt;/item&gt;</a>
<a href="../engine/parser/ast.cs.html#1839"><b>1839</b>/// &lt;item&gt;&lt;see cref=&quot;<i>TokenKind</i>.End&quot;/&gt;&lt;/item&gt;</a>
<a href="../engine/parser/ast.cs.html#1840"><b>1840</b>/// &lt;item&gt;&lt;see cref=&quot;<i>TokenKind</i>.Dynamicparam&quot;/&gt;&lt;/item&gt;</a>
<a href="../engine/parser/ast.cs.html#1843"><b>1843</b>public <i>TokenKind</i> BlockKind { get; }</a>
<a href="../engine/parser/ast.cs.html#3653"><b>3653</b>(functionNameToken.Kind == <i>TokenKind</i>.Generic) ? ((StringToken)functionNameToken).Value : functionNameToken.Text,</a>
<a href="../engine/parser/ast.cs.html#5409"><b>5409</b><i>TokenKind</i> chainOperator,</a>
<a href="../engine/parser/ast.cs.html#5423"><b>5423</b>if (chainOperator != <i>TokenKind</i>.AndAnd &amp;&amp; chainOperator != <i>TokenKind</i>.OrOr)</a>
<a href="../engine/parser/ast.cs.html#5450"><b>5450</b>public <i>TokenKind</i> Operator { get; }</a>
<a href="../engine/parser/ast.cs.html#5859"><b>5859</b><i>TokenKind</i> invocationOperator,</a>
<a href="../engine/parser/ast.cs.html#5868"><b>5868</b>if (invocationOperator != <i>TokenKind</i>.Dot &amp;&amp; invocationOperator != <i>TokenKind</i>.Ampersand &amp;&amp; invocationOperator != <i>TokenKind</i>.Unknown)</a>
<a href="../engine/parser/ast.cs.html#5884"><b>5884</b>/// The invocation operator (either &lt;see cref=&quot;<i>TokenKind</i>.Dot&quot;/&gt; or &lt;see cref=&quot;<i>TokenKind</i>.Ampersand&quot;/&gt;) if one was specified,</a>
<a href="../engine/parser/ast.cs.html#5885"><b>5885</b>/// otherwise the value is &lt;see cref=&quot;<i>TokenKind</i>.Unknown&quot;/&gt;.</a>
<a href="../engine/parser/ast.cs.html#5887"><b>5887</b>public <i>TokenKind</i> InvocationOperator { get; }</a>
<a href="../engine/parser/ast.cs.html#6245"><b>6245</b>public AssignmentStatementAst(IScriptExtent extent, ExpressionAst left, <i>TokenKind</i> @operator, StatementAst right, IScriptExtent errorPosition)</a>
<a href="../engine/parser/ast.cs.html#6291"><b>6291</b>public <i>TokenKind</i> Operator { get; }</a>
<a href="../engine/parser/ast.cs.html#6598"><b>6598</b>var cmdAst = new CommandAst(this.Extent, cea, <i>TokenKind</i>.Unknown, null);</a>
<a href="../engine/parser/ast.cs.html#6620"><b>6620</b><i>TokenKind</i>.Plus,</a>
<a href="../engine/parser/ast.cs.html#6637"><b>6637</b>var setItemCmdlet = new CommandAst(this.Extent, setItemCmdElements, <i>TokenKind</i>.Unknown, null);</a>
<a href="../engine/parser/ast.cs.html#6664"><b>6664</b>var commandAst = new CommandAst(dkwsAst.Extent, CopyElements(dkwsAst.CommandElements), <i>TokenKind</i>.Unknown, null);</a>
<a href="../engine/parser/ast.cs.html#7190"><b>7190</b>var cmdAst = new CommandAst(FunctionName.Extent, cea, <i>TokenKind</i>.Unknown, null);</a>
<a href="../engine/parser/ast.cs.html#7387"><b>7387</b>public BinaryExpressionAst(IScriptExtent extent, ExpressionAst left, <i>TokenKind</i> @operator, ExpressionAst right, IScriptExtent errorPosition)</a>
<a href="../engine/parser/ast.cs.html#7411"><b>7411</b>public <i>TokenKind</i> Operator { get; }</a>
<a href="../engine/parser/ast.cs.html#7448"><b>7448</b>case <i>TokenKind</i>.Xor:</a>
<a href="../engine/parser/ast.cs.html#7449"><b>7449</b>case <i>TokenKind</i>.And:</a>
<a href="../engine/parser/ast.cs.html#7450"><b>7450</b>case <i>TokenKind</i>.Or:</a>
<a href="../engine/parser/ast.cs.html#7451"><b>7451</b>case <i>TokenKind</i>.Is:</a>
<a href="../engine/parser/ast.cs.html#7500"><b>7500</b>public UnaryExpressionAst(IScriptExtent extent, <i>TokenKind</i> tokenKind, ExpressionAst child)</a>
<a href="../engine/parser/ast.cs.html#7521"><b>7521</b>public <i>TokenKind</i> TokenKind { get; }</a>
<a href="../engine/parser/ast.cs.html#7544"><b>7544</b>return (TokenKind == <i>TokenKind</i>.Not || TokenKind == <i>TokenKind</i>.Exclaim)</a>
<a href="../engine/parser/ast.cs.html#7590"><b>7590</b>if (kind.Kind != <i>TokenKind</i>.Sequence &amp;&amp; kind.Kind != <i>TokenKind</i>.Parallel)</a>
<a href="../engine/parser/ast.cs.html#9161"><b>9161</b>: this(token.Extent, token.VariablePath, (token.Kind == <i>TokenKind</i>.SplattedVariable))</a>
<a href="../engine/parser/ast.cs.html#9515"><b>9515</b>case <i>TokenKind</i>.StringExpandable:</a>
<a href="../engine/parser/ast.cs.html#9517"><b>9517</b>case <i>TokenKind</i>.HereStringLiteral:</a>
<a href="../engine/parser/ast.cs.html#9519"><b>9519</b>case <i>TokenKind</i>.HereStringExpandable:</a>
<a href="../engine/parser/ast.cs.html#9521"><b>9521</b>case <i>TokenKind</i>.StringLiteral:</a>
<a href="../engine/parser/ast.cs.html#9523"><b>9523</b>case <i>TokenKind</i>.Generic:</a>
</div>
<div class="rF"><div class="rN">engine\parser\Compiler.cs (80)</div>
<a href="../engine/parser/Compiler.cs.html#971"><b>971</b>internal Expression ReduceAssignment(ISupportsAssignment left, <i>TokenKind</i> tokenKind, Expression right)</a>
<a href="../engine/parser/Compiler.cs.html#978"><b>978</b>case <i>TokenKind</i>.Equals: return av.SetValue(this, right);</a>
<a href="../engine/parser/Compiler.cs.html#979"><b>979</b>case <i>TokenKind</i>.PlusEquals: et = ExpressionType.Add; break;</a>
<a href="../engine/parser/Compiler.cs.html#980"><b>980</b>case <i>TokenKind</i>.MinusEquals: et = ExpressionType.Subtract; break;</a>
<a href="../engine/parser/Compiler.cs.html#981"><b>981</b>case <i>TokenKind</i>.MultiplyEquals: et = ExpressionType.Multiply; break;</a>
<a href="../engine/parser/Compiler.cs.html#982"><b>982</b>case <i>TokenKind</i>.DivideEquals: et = ExpressionType.Divide; break;</a>
<a href="../engine/parser/Compiler.cs.html#983"><b>983</b>case <i>TokenKind</i>.RemainderEquals: et = ExpressionType.Modulo; break;</a>
<a href="../engine/parser/Compiler.cs.html#984"><b>984</b>case <i>TokenKind</i>.QuestionQuestionEquals: et = ExpressionType.Coalesce; break;</a>
<a href="../engine/parser/Compiler.cs.html#3642"><b>3642</b>currentChain.Operator == <i>TokenKind</i>.AndAnd || currentChain.Operator == <i>TokenKind</i>.OrOr,</a>
<a href="../engine/parser/Compiler.cs.html#3645"><b>3645</b>Expression dollarQuestionCheck = currentChain.Operator == <i>TokenKind</i>.AndAnd</a>
<a href="../engine/parser/Compiler.cs.html#5054"><b>5054</b>exprs.Add(ReduceAssignment(forEachStatementAst.Variable, <i>TokenKind</i>.Equals, newValue));</a>
<a href="../engine/parser/Compiler.cs.html#5071"><b>5071</b>if (binaryExpr != null &amp;&amp; binaryExpr.Operator == <i>TokenKind</i>.DotDot)</a>
<a href="../engine/parser/Compiler.cs.html#5675"><b>5675</b>case <i>TokenKind</i>.And:</a>
<a href="../engine/parser/Compiler.cs.html#5677"><b>5677</b>case <i>TokenKind</i>.Or:</a>
<a href="../engine/parser/Compiler.cs.html#5679"><b>5679</b>case <i>TokenKind</i>.Is:</a>
<a href="../engine/parser/Compiler.cs.html#5680"><b>5680</b>case <i>TokenKind</i>.IsNot:</a>
<a href="../engine/parser/Compiler.cs.html#5687"><b>5687</b>if (binaryExpressionAst.Operator == <i>TokenKind</i>.Is)</a>
<a href="../engine/parser/Compiler.cs.html#5697"><b>5697</b>if (binaryExpressionAst.Operator == <i>TokenKind</i>.IsNot)</a>
<a href="../engine/parser/Compiler.cs.html#5704"><b>5704</b>case <i>TokenKind</i>.As:</a>
<a href="../engine/parser/Compiler.cs.html#5707"><b>5707</b>case <i>TokenKind</i>.DotDot:</a>
<a href="../engine/parser/Compiler.cs.html#5715"><b>5715</b>case <i>TokenKind</i>.Multiply:</a>
<a href="../engine/parser/Compiler.cs.html#5723"><b>5723</b>case <i>TokenKind</i>.Divide:</a>
<a href="../engine/parser/Compiler.cs.html#5731"><b>5731</b>case <i>TokenKind</i>.Rem:</a>
<a href="../engine/parser/Compiler.cs.html#5734"><b>5734</b>case <i>TokenKind</i>.Plus:</a>
<a href="../engine/parser/Compiler.cs.html#5742"><b>5742</b>case <i>TokenKind</i>.Minus:</a>
<a href="../engine/parser/Compiler.cs.html#5750"><b>5750</b>case <i>TokenKind</i>.Format:</a>
<a href="../engine/parser/Compiler.cs.html#5757"><b>5757</b>case <i>TokenKind</i>.Xor:</a>
<a href="../engine/parser/Compiler.cs.html#5759"><b>5759</b>case <i>TokenKind</i>.Shl:</a>
<a href="../engine/parser/Compiler.cs.html#5762"><b>5762</b>case <i>TokenKind</i>.Shr:</a>
<a href="../engine/parser/Compiler.cs.html#5765"><b>5765</b>case <i>TokenKind</i>.Band:</a>
<a href="../engine/parser/Compiler.cs.html#5768"><b>5768</b>case <i>TokenKind</i>.Bor:</a>
<a href="../engine/parser/Compiler.cs.html#5771"><b>5771</b>case <i>TokenKind</i>.Bxor:</a>
<a href="../engine/parser/Compiler.cs.html#5774"><b>5774</b>case <i>TokenKind</i>.Join:</a>
<a href="../engine/parser/Compiler.cs.html#5782"><b>5782</b>case <i>TokenKind</i>.Ieq:</a>
<a href="../engine/parser/Compiler.cs.html#5785"><b>5785</b>case <i>TokenKind</i>.Ine:</a>
<a href="../engine/parser/Compiler.cs.html#5788"><b>5788</b>case <i>TokenKind</i>.Ige:</a>
<a href="../engine/parser/Compiler.cs.html#5791"><b>5791</b>case <i>TokenKind</i>.Igt:</a>
<a href="../engine/parser/Compiler.cs.html#5794"><b>5794</b>case <i>TokenKind</i>.Ilt:</a>
<a href="../engine/parser/Compiler.cs.html#5797"><b>5797</b>case <i>TokenKind</i>.Ile:</a>
<a href="../engine/parser/Compiler.cs.html#5800"><b>5800</b>case <i>TokenKind</i>.Ilike:</a>
<a href="../engine/parser/Compiler.cs.html#5809"><b>5809</b>case <i>TokenKind</i>.Inotlike:</a>
<a href="../engine/parser/Compiler.cs.html#5818"><b>5818</b>case <i>TokenKind</i>.Imatch:</a>
<a href="../engine/parser/Compiler.cs.html#5828"><b>5828</b>case <i>TokenKind</i>.Inotmatch:</a>
<a href="../engine/parser/Compiler.cs.html#5838"><b>5838</b>case <i>TokenKind</i>.Ireplace:</a>
<a href="../engine/parser/Compiler.cs.html#5847"><b>5847</b>case <i>TokenKind</i>.Icontains:</a>
<a href="../engine/parser/Compiler.cs.html#5849"><b>5849</b>case <i>TokenKind</i>.Inotcontains:</a>
<a href="../engine/parser/Compiler.cs.html#5851"><b>5851</b>case <i>TokenKind</i>.Iin:</a>
<a href="../engine/parser/Compiler.cs.html#5853"><b>5853</b>case <i>TokenKind</i>.Inotin:</a>
<a href="../engine/parser/Compiler.cs.html#5855"><b>5855</b>case <i>TokenKind</i>.Isplit:</a>
<a href="../engine/parser/Compiler.cs.html#5864"><b>5864</b>case <i>TokenKind</i>.Ceq:</a>
<a href="../engine/parser/Compiler.cs.html#5867"><b>5867</b>case <i>TokenKind</i>.Cne:</a>
<a href="../engine/parser/Compiler.cs.html#5870"><b>5870</b>case <i>TokenKind</i>.Cge:</a>
<a href="../engine/parser/Compiler.cs.html#5873"><b>5873</b>case <i>TokenKind</i>.Cgt:</a>
<a href="../engine/parser/Compiler.cs.html#5876"><b>5876</b>case <i>TokenKind</i>.Clt:</a>
<a href="../engine/parser/Compiler.cs.html#5879"><b>5879</b>case <i>TokenKind</i>.Cle:</a>
<a href="../engine/parser/Compiler.cs.html#5882"><b>5882</b>case <i>TokenKind</i>.Clike:</a>
<a href="../engine/parser/Compiler.cs.html#5891"><b>5891</b>case <i>TokenKind</i>.Cnotlike:</a>
<a href="../engine/parser/Compiler.cs.html#5900"><b>5900</b>case <i>TokenKind</i>.Cmatch:</a>
<a href="../engine/parser/Compiler.cs.html#5910"><b>5910</b>case <i>TokenKind</i>.Cnotmatch:</a>
<a href="../engine/parser/Compiler.cs.html#5920"><b>5920</b>case <i>TokenKind</i>.Creplace:</a>
<a href="../engine/parser/Compiler.cs.html#5929"><b>5929</b>case <i>TokenKind</i>.Ccontains:</a>
<a href="../engine/parser/Compiler.cs.html#5931"><b>5931</b>case <i>TokenKind</i>.Cnotcontains:</a>
<a href="../engine/parser/Compiler.cs.html#5933"><b>5933</b>case <i>TokenKind</i>.Cin:</a>
<a href="../engine/parser/Compiler.cs.html#5935"><b>5935</b>case <i>TokenKind</i>.Cnotin:</a>
<a href="../engine/parser/Compiler.cs.html#5937"><b>5937</b>case <i>TokenKind</i>.Csplit:</a>
<a href="../engine/parser/Compiler.cs.html#5946"><b>5946</b>case <i>TokenKind</i>.QuestionQuestion:</a>
<a href="../engine/parser/Compiler.cs.html#5979"><b>5979</b>case <i>TokenKind</i>.Exclaim:</a>
<a href="../engine/parser/Compiler.cs.html#5980"><b>5980</b>case <i>TokenKind</i>.Not:</a>
<a href="../engine/parser/Compiler.cs.html#5982"><b>5982</b>case <i>TokenKind</i>.Minus:</a>
<a href="../engine/parser/Compiler.cs.html#5988"><b>5988</b>case <i>TokenKind</i>.Plus:</a>
<a href="../engine/parser/Compiler.cs.html#5994"><b>5994</b>case <i>TokenKind</i>.Bnot:</a>
<a href="../engine/parser/Compiler.cs.html#5999"><b>5999</b>case <i>TokenKind</i>.PlusPlus:</a>
<a href="../engine/parser/Compiler.cs.html#6001"><b>6001</b>case <i>TokenKind</i>.MinusMinus:</a>
<a href="../engine/parser/Compiler.cs.html#6003"><b>6003</b>case <i>TokenKind</i>.PostfixPlusPlus:</a>
<a href="../engine/parser/Compiler.cs.html#6005"><b>6005</b>case <i>TokenKind</i>.PostfixMinusMinus:</a>
<a href="../engine/parser/Compiler.cs.html#6007"><b>6007</b>case <i>TokenKind</i>.Join:</a>
<a href="../engine/parser/Compiler.cs.html#6014"><b>6014</b>case <i>TokenKind</i>.Isplit:</a>
<a href="../engine/parser/Compiler.cs.html#6015"><b>6015</b>case <i>TokenKind</i>.Csplit:</a>
<a href="../engine/parser/Compiler.cs.html#6888"><b>6888</b>exprs.Add(compiler.ReduceAssignment((ISupportsAssignment)lhsElement, <i>TokenKind</i>.Equals, indexedRHS));</a>
</div>
<div class="rF"><div class="rN">engine\parser\ConstantValues.cs (4)</div>
<a href="../engine/parser/ConstantValues.cs.html#178"><b>178</b>case <i>TokenKind</i>.Divide:</a>
<a href="../engine/parser/ConstantValues.cs.html#179"><b>179</b>case <i>TokenKind</i>.DivideEquals:</a>
<a href="../engine/parser/ConstantValues.cs.html#180"><b>180</b>case <i>TokenKind</i>.Rem:</a>
<a href="../engine/parser/ConstantValues.cs.html#181"><b>181</b>case <i>TokenKind</i>.RemainderEquals:</a>
</div>
<div class="rF"><div class="rN">engine\parser\Parser.cs (387)</div>
<a href="../engine/parser/Parser.cs.html#315"><b>315</b>return (token.Kind == <i>TokenKind</i>.Variable || token.Kind == <i>TokenKind</i>.Generic) &amp;&amp;</a>
<a href="../engine/parser/Parser.cs.html#353"><b>353</b>if (_ungotToken == null || _ungotToken.Kind == <i>TokenKind</i>.NewLine)</a>
<a href="../engine/parser/Parser.cs.html#362"><b>362</b>if (_ungotToken == null || _ungotToken.Kind == <i>TokenKind</i>.NewLine || _ungotToken.Kind == <i>TokenKind</i>.Semi)</a>
<a href="../engine/parser/Parser.cs.html#369"><b>369</b>private void SyncOnError(bool consumeClosingToken, params <i>TokenKind</i>[] syncTokens)</a>
<a href="../engine/parser/Parser.cs.html#371"><b>371</b>int parens = syncTokens.Contains(<i>TokenKind</i>.RParen) ? 1 : 0;</a>
<a href="../engine/parser/Parser.cs.html#372"><b>372</b>int curlies = syncTokens.Contains(<i>TokenKind</i>.RCurly) ? 1 : 0;</a>
<a href="../engine/parser/Parser.cs.html#373"><b>373</b>int braces = syncTokens.Contains(<i>TokenKind</i>.RBracket) ? 1 : 0;</a>
<a href="../engine/parser/Parser.cs.html#379"><b>379</b>case <i>TokenKind</i>.LParen: ++parens; break;</a>
<a href="../engine/parser/Parser.cs.html#380"><b>380</b>case <i>TokenKind</i>.RParen:</a>
<a href="../engine/parser/Parser.cs.html#382"><b>382</b>if (parens == 0 &amp;&amp; syncTokens.Contains(<i>TokenKind</i>.RParen))</a>
<a href="../engine/parser/Parser.cs.html#394"><b>394</b>case <i>TokenKind</i>.LCurly: ++curlies; break;</a>
<a href="../engine/parser/Parser.cs.html#395"><b>395</b>case <i>TokenKind</i>.RCurly:</a>
<a href="../engine/parser/Parser.cs.html#397"><b>397</b>if (curlies == 0 &amp;&amp; syncTokens.Contains(<i>TokenKind</i>.RCurly))</a>
<a href="../engine/parser/Parser.cs.html#409"><b>409</b>case <i>TokenKind</i>.LBracket: ++braces; break;</a>
<a href="../engine/parser/Parser.cs.html#410"><b>410</b>case <i>TokenKind</i>.RBracket:</a>
<a href="../engine/parser/Parser.cs.html#412"><b>412</b>if (braces == 0 &amp;&amp; syncTokens.Contains(<i>TokenKind</i>.RBracket))</a>
<a href="../engine/parser/Parser.cs.html#424"><b>424</b>case <i>TokenKind</i>.EndOfInput:</a>
<a href="../engine/parser/Parser.cs.html#472"><b>472</b>if (_ungotToken.Kind == <i>TokenKind</i>.LBracket) return NextToken();</a>
<a href="../engine/parser/Parser.cs.html#482"><b>482</b>if (_ungotToken == null || _ungotToken.Kind == <i>TokenKind</i>.Parameter)</a>
<a href="../engine/parser/Parser.cs.html#513"><b>513</b>else if (_ungotToken.Kind != <i>TokenKind</i>.EndOfInput)</a>
<a href="../engine/parser/Parser.cs.html#556"><b>556</b>Diagnostics.Assert(token.Kind == <i>TokenKind</i>.Parameter, &quot;Token must be a ParameterToken&quot;);</a>
<a href="../engine/parser/Parser.cs.html#564"><b>564</b>if (terminatorToken.Kind == <i>TokenKind</i>.NewLine || terminatorToken.Kind == <i>TokenKind</i>.Semi)</a>
<a href="../engine/parser/Parser.cs.html#568"><b>568</b>else if (terminatorToken.Kind != <i>TokenKind</i>.EndOfInput)</a>
<a href="../engine/parser/Parser.cs.html#821"><b>821</b>if (token.Kind == <i>TokenKind</i>.Using)</a>
<a href="../engine/parser/Parser.cs.html#862"><b>862</b>if (paramToken.Kind != <i>TokenKind</i>.Param)</a>
<a href="../engine/parser/Parser.cs.html#870"><b>870</b>if (lparen.Kind != <i>TokenKind</i>.LParen)</a>
<a href="../engine/parser/Parser.cs.html#883"><b>883</b>if (rParen.Kind != <i>TokenKind</i>.RParen)</a>
<a href="../engine/parser/Parser.cs.html#949"><b>949</b>if (commaToken.Kind != <i>TokenKind</i>.Comma)</a>
<a href="../engine/parser/Parser.cs.html#982"><b>982</b>if (token.Kind != <i>TokenKind</i>.Variable &amp;&amp; token.Kind != <i>TokenKind</i>.SplattedVariable)</a>
<a href="../engine/parser/Parser.cs.html#992"><b>992</b>SyncOnError(true, <i>TokenKind</i>.RParen);</a>
<a href="../engine/parser/Parser.cs.html#1007"><b>1007</b>if (equalsToken.Kind == <i>TokenKind</i>.Equals)</a>
<a href="../engine/parser/Parser.cs.html#1089"><b>1089</b>if (lParenOrRBracket.Kind == <i>TokenKind</i>.LParen)</a>
<a href="../engine/parser/Parser.cs.html#1110"><b>1110</b>if (rParen.Kind != <i>TokenKind</i>.RParen)</a>
<a href="../engine/parser/Parser.cs.html#1123"><b>1123</b>if (rBracket.Kind != <i>TokenKind</i>.RBracket)</a>
<a href="../engine/parser/Parser.cs.html#1145"><b>1145</b><i>TokenKind</i>.Identifier, TokenFlags.TypeName);</a>
<a href="../engine/parser/Parser.cs.html#1149"><b>1149</b>if (lParenOrRBracket.Kind != <i>TokenKind</i>.RBracket)</a>
<a href="../engine/parser/Parser.cs.html#1189"><b>1189</b>if (token.Kind == <i>TokenKind</i>.Equals)</a>
<a href="../engine/parser/Parser.cs.html#1206"><b>1206</b>SyncOnError(true, <i>TokenKind</i>.Comma, <i>TokenKind</i>.RParen, <i>TokenKind</i>.RBracket, <i>TokenKind</i>.NewLine);</a>
<a href="../engine/parser/Parser.cs.html#1262"><b>1262</b>if (commaToken.Kind != <i>TokenKind</i>.Comma)</a>
<a href="../engine/parser/Parser.cs.html#1321"><b>1321</b>if (typeName.Kind != <i>TokenKind</i>.Identifier)</a>
<a href="../engine/parser/Parser.cs.html#1341"><b>1341</b>Diagnostics.Assert(typeName.Kind == <i>TokenKind</i>.Identifier, &quot;Caller must verify the argument.&quot;);</a>
<a href="../engine/parser/Parser.cs.html#1343"><b>1343</b>if (token.Kind == <i>TokenKind</i>.LBracket)</a>
<a href="../engine/parser/Parser.cs.html#1353"><b>1353</b>case <i>TokenKind</i>.RBracket:</a>
<a href="../engine/parser/Parser.cs.html#1354"><b>1354</b>case <i>TokenKind</i>.Comma:</a>
<a href="../engine/parser/Parser.cs.html#1358"><b>1358</b>case <i>TokenKind</i>.LBracket:</a>
<a href="../engine/parser/Parser.cs.html#1359"><b>1359</b>case <i>TokenKind</i>.Identifier:</a>
<a href="../engine/parser/Parser.cs.html#1365"><b>1365</b>if (token.Kind != <i>TokenKind</i>.EndOfInput)</a>
<a href="../engine/parser/Parser.cs.html#1371"><b>1371</b>SyncOnError(true, <i>TokenKind</i>.RBracket);</a>
<a href="../engine/parser/Parser.cs.html#1385"><b>1385</b>if (token.Kind == <i>TokenKind</i>.Comma &amp;&amp; allowAssemblyQualifiedNames &amp;&amp; !unBracketedGenericArg)</a>
<a href="../engine/parser/Parser.cs.html#1405"><b>1405</b>if (firstToken.Kind == <i>TokenKind</i>.Identifier)</a>
<a href="../engine/parser/Parser.cs.html#1410"><b>1410</b>Diagnostics.Assert(firstToken.Kind == <i>TokenKind</i>.LBracket, &quot;caller to verify correct token kind&quot;);</a>
<a href="../engine/parser/Parser.cs.html#1413"><b>1413</b>if (token.Kind != <i>TokenKind</i>.Identifier)</a>
<a href="../engine/parser/Parser.cs.html#1426"><b>1426</b>if (rBracket.Kind != <i>TokenKind</i>.RBracket)</a>
<a href="../engine/parser/Parser.cs.html#1442"><b>1442</b>Diagnostics.Assert(firstToken.Kind == <i>TokenKind</i>.Identifier || firstToken.Kind == <i>TokenKind</i>.LBracket, &quot;unexpected first token&quot;);</a>
<a href="../engine/parser/Parser.cs.html#1455"><b>1455</b>if (commaOrRBracketToken.Kind != <i>TokenKind</i>.Comma)</a>
<a href="../engine/parser/Parser.cs.html#1463"><b>1463</b>if (token.Kind == <i>TokenKind</i>.Identifier || token.Kind == <i>TokenKind</i>.LBracket)</a>
<a href="../engine/parser/Parser.cs.html#1479"><b>1479</b>if (commaOrRBracketToken.Kind != <i>TokenKind</i>.RBracket)</a>
<a href="../engine/parser/Parser.cs.html#1494"><b>1494</b>if (token.Kind == <i>TokenKind</i>.LBracket)</a>
<a href="../engine/parser/Parser.cs.html#1500"><b>1500</b>if (token.Kind == <i>TokenKind</i>.Comma &amp;&amp; !unBracketedGenericArg)</a>
<a href="../engine/parser/Parser.cs.html#1526"><b>1526</b>case <i>TokenKind</i>.Comma:</a>
<a href="../engine/parser/Parser.cs.html#1535"><b>1535</b>} while (token.Kind == <i>TokenKind</i>.Comma);</a>
<a href="../engine/parser/Parser.cs.html#1537"><b>1537</b>if (token.Kind != <i>TokenKind</i>.RBracket)</a>
<a href="../engine/parser/Parser.cs.html#1550"><b>1550</b>case <i>TokenKind</i>.RBracket:</a>
<a href="../engine/parser/Parser.cs.html#1554"><b>1554</b>case <i>TokenKind</i>.EndOfInput:</a>
<a href="../engine/parser/Parser.cs.html#1568"><b>1568</b>SyncOnError(true, <i>TokenKind</i>.RBracket);</a>
<a href="../engine/parser/Parser.cs.html#1573"><b>1573</b>if (token.Kind == <i>TokenKind</i>.Comma)</a>
<a href="../engine/parser/Parser.cs.html#1591"><b>1591</b>if (token.Kind != <i>TokenKind</i>.LBracket)</a>
<a href="../engine/parser/Parser.cs.html#1612"><b>1612</b>if (rCurly.Kind != <i>TokenKind</i>.RCurly)</a>
<a href="../engine/parser/Parser.cs.html#1641"><b>1641</b>if (token.Kind != <i>TokenKind</i>.EndOfInput)</a>
<a href="../engine/parser/Parser.cs.html#1749"><b>1749</b>case <i>TokenKind</i>.RCurly:</a>
<a href="../engine/parser/Parser.cs.html#1750"><b>1750</b>case <i>TokenKind</i>.EndOfInput:</a>
<a href="../engine/parser/Parser.cs.html#1756"><b>1756</b>case <i>TokenKind</i>.Dynamicparam:</a>
<a href="../engine/parser/Parser.cs.html#1757"><b>1757</b>case <i>TokenKind</i>.Begin:</a>
<a href="../engine/parser/Parser.cs.html#1758"><b>1758</b>case <i>TokenKind</i>.Process:</a>
<a href="../engine/parser/Parser.cs.html#1759"><b>1759</b>case <i>TokenKind</i>.End:</a>
<a href="../engine/parser/Parser.cs.html#1788"><b>1788</b>if (blockNameToken.Kind == <i>TokenKind</i>.Begin &amp;&amp; beginBlock == null)</a>
<a href="../engine/parser/Parser.cs.html#1790"><b>1790</b>beginBlock = new NamedBlockAst(extent, <i>TokenKind</i>.Begin, statementBlock, false);</a>
<a href="../engine/parser/Parser.cs.html#1792"><b>1792</b>else if (blockNameToken.Kind == <i>TokenKind</i>.Process &amp;&amp; processBlock == null)</a>
<a href="../engine/parser/Parser.cs.html#1794"><b>1794</b>processBlock = new NamedBlockAst(extent, <i>TokenKind</i>.Process, statementBlock, false);</a>
<a href="../engine/parser/Parser.cs.html#1796"><b>1796</b>else if (blockNameToken.Kind == <i>TokenKind</i>.End &amp;&amp; endBlock == null)</a>
<a href="../engine/parser/Parser.cs.html#1798"><b>1798</b>endBlock = new NamedBlockAst(extent, <i>TokenKind</i>.End, statementBlock, false);</a>
<a href="../engine/parser/Parser.cs.html#1800"><b>1800</b>else if (blockNameToken.Kind == <i>TokenKind</i>.Dynamicparam &amp;&amp; dynamicParamBlock == null)</a>
<a href="../engine/parser/Parser.cs.html#1802"><b>1802</b>dynamicParamBlock = new NamedBlockAst(extent, <i>TokenKind</i>.Dynamicparam, statementBlock, false);</a>
<a href="../engine/parser/Parser.cs.html#1832"><b>1832</b>if (lCurly.Kind != <i>TokenKind</i>.LCurly)</a>
<a href="../engine/parser/Parser.cs.html#1844"><b>1844</b>if (rCurly.Kind != <i>TokenKind</i>.RCurly)</a>
<a href="../engine/parser/Parser.cs.html#1906"><b>1906</b>if (token.Kind == <i>TokenKind</i>.RParen || token.Kind == <i>TokenKind</i>.RCurly)</a>
<a href="../engine/parser/Parser.cs.html#1955"><b>1955</b>if (token.Kind == <i>TokenKind</i>.Generic &amp;&amp; token.Text[0] == &#39;[&#39;)</a>
<a href="../engine/parser/Parser.cs.html#2001"><b>2001</b>case <i>TokenKind</i>.If:</a>
<a href="../engine/parser/Parser.cs.html#2004"><b>2004</b>case <i>TokenKind</i>.Switch:</a>
<a href="../engine/parser/Parser.cs.html#2007"><b>2007</b>case <i>TokenKind</i>.Foreach:</a>
<a href="../engine/parser/Parser.cs.html#2010"><b>2010</b>case <i>TokenKind</i>.For:</a>
<a href="../engine/parser/Parser.cs.html#2013"><b>2013</b>case <i>TokenKind</i>.While:</a>
<a href="../engine/parser/Parser.cs.html#2016"><b>2016</b>case <i>TokenKind</i>.Do:</a>
<a href="../engine/parser/Parser.cs.html#2019"><b>2019</b>case <i>TokenKind</i>.Function:</a>
<a href="../engine/parser/Parser.cs.html#2020"><b>2020</b>case <i>TokenKind</i>.Filter:</a>
<a href="../engine/parser/Parser.cs.html#2021"><b>2021</b>case <i>TokenKind</i>.Workflow:</a>
<a href="../engine/parser/Parser.cs.html#2024"><b>2024</b>case <i>TokenKind</i>.Return:</a>
<a href="../engine/parser/Parser.cs.html#2027"><b>2027</b>case <i>TokenKind</i>.Throw:</a>
<a href="../engine/parser/Parser.cs.html#2030"><b>2030</b>case <i>TokenKind</i>.Exit:</a>
<a href="../engine/parser/Parser.cs.html#2033"><b>2033</b>case <i>TokenKind</i>.Break:</a>
<a href="../engine/parser/Parser.cs.html#2036"><b>2036</b>case <i>TokenKind</i>.Continue:</a>
<a href="../engine/parser/Parser.cs.html#2039"><b>2039</b>case <i>TokenKind</i>.Trap:</a>
<a href="../engine/parser/Parser.cs.html#2042"><b>2042</b>case <i>TokenKind</i>.Try:</a>
<a href="../engine/parser/Parser.cs.html#2045"><b>2045</b>case <i>TokenKind</i>.Data:</a>
<a href="../engine/parser/Parser.cs.html#2048"><b>2048</b>case <i>TokenKind</i>.Parallel:</a>
<a href="../engine/parser/Parser.cs.html#2049"><b>2049</b>case <i>TokenKind</i>.Sequence:</a>
<a href="../engine/parser/Parser.cs.html#2052"><b>2052</b>case <i>TokenKind</i>.Configuration:</a>
<a href="../engine/parser/Parser.cs.html#2055"><b>2055</b>case <i>TokenKind</i>.From:</a>
<a href="../engine/parser/Parser.cs.html#2056"><b>2056</b>case <i>TokenKind</i>.Define:</a>
<a href="../engine/parser/Parser.cs.html#2057"><b>2057</b>case <i>TokenKind</i>.Var:</a>
<a href="../engine/parser/Parser.cs.html#2064"><b>2064</b>case <i>TokenKind</i>.Label:</a>
<a href="../engine/parser/Parser.cs.html#2068"><b>2068</b>case <i>TokenKind</i>.EndOfInput:</a>
<a href="../engine/parser/Parser.cs.html#2081"><b>2081</b>case <i>TokenKind</i>.Else:</a>
<a href="../engine/parser/Parser.cs.html#2082"><b>2082</b>case <i>TokenKind</i>.ElseIf:</a>
<a href="../engine/parser/Parser.cs.html#2083"><b>2083</b>case <i>TokenKind</i>.Catch:</a>
<a href="../engine/parser/Parser.cs.html#2084"><b>2084</b>case <i>TokenKind</i>.Until:</a>
<a href="../engine/parser/Parser.cs.html#2095"><b>2095</b>case <i>TokenKind</i>.DynamicKeyword:</a>
<a href="../engine/parser/Parser.cs.html#2099"><b>2099</b>case <i>TokenKind</i>.Class:</a>
<a href="../engine/parser/Parser.cs.html#2102"><b>2102</b>case <i>TokenKind</i>.Enum:</a>
<a href="../engine/parser/Parser.cs.html#2105"><b>2105</b>case <i>TokenKind</i>.Using:</a>
<a href="../engine/parser/Parser.cs.html#2148"><b>2148</b>if (token.Kind == <i>TokenKind</i>.Identifier)</a>
<a href="../engine/parser/Parser.cs.html#2177"><b>2177</b>if (token.Kind != <i>TokenKind</i>.NewLine &amp;&amp; token.Kind != <i>TokenKind</i>.Semi)</a>
<a href="../engine/parser/Parser.cs.html#2285"><b>2285</b>case <i>TokenKind</i>.Switch:</a>
<a href="../engine/parser/Parser.cs.html#2288"><b>2288</b>case <i>TokenKind</i>.Foreach:</a>
<a href="../engine/parser/Parser.cs.html#2291"><b>2291</b>case <i>TokenKind</i>.For:</a>
<a href="../engine/parser/Parser.cs.html#2294"><b>2294</b>case <i>TokenKind</i>.While:</a>
<a href="../engine/parser/Parser.cs.html#2297"><b>2297</b>case <i>TokenKind</i>.Do:</a>
<a href="../engine/parser/Parser.cs.html#2352"><b>2352</b>if (lCurly.Kind != <i>TokenKind</i>.LCurly)</a>
<a href="../engine/parser/Parser.cs.html#2390"><b>2390</b>if (lParen.Kind != <i>TokenKind</i>.LParen)</a>
<a href="../engine/parser/Parser.cs.html#2425"><b>2425</b>if (rParen.Kind != <i>TokenKind</i>.RParen)</a>
<a href="../engine/parser/Parser.cs.html#2475"><b>2475</b>if (keyword.Kind == <i>TokenKind</i>.ElseIf)</a>
<a href="../engine/parser/Parser.cs.html#2480"><b>2480</b>else if (keyword.Kind == <i>TokenKind</i>.Else)</a>
<a href="../engine/parser/Parser.cs.html#2555"><b>2555</b>while (switchParameterToken.Kind == <i>TokenKind</i>.Parameter)</a>
<a href="../engine/parser/Parser.cs.html#2654"><b>2654</b>if (switchParameterToken.Kind == <i>TokenKind</i>.Minus)</a>
<a href="../engine/parser/Parser.cs.html#2661"><b>2661</b>if (lParen.Kind == <i>TokenKind</i>.LParen)</a>
<a href="../engine/parser/Parser.cs.html#2695"><b>2695</b>if (rParen.Kind != <i>TokenKind</i>.RParen)</a>
<a href="../engine/parser/Parser.cs.html#2735"><b>2735</b>if (lCurly.Kind != <i>TokenKind</i>.LCurly)</a>
<a href="../engine/parser/Parser.cs.html#2756"><b>2756</b>bool isDefaultClause = token.Kind == <i>TokenKind</i>.Default;</a>
<a href="../engine/parser/Parser.cs.html#2779"><b>2779</b>if (PeekToken().Kind == <i>TokenKind</i>.RCurly)</a>
<a href="../engine/parser/Parser.cs.html#2829"><b>2829</b>if (token.Kind == <i>TokenKind</i>.RCurly)</a>
<a href="../engine/parser/Parser.cs.html#2836"><b>2836</b>if (token.Kind == <i>TokenKind</i>.EndOfInput)</a>
<a href="../engine/parser/Parser.cs.html#2883"><b>2883</b>if (configurationNameToken.Kind == <i>TokenKind</i>.LCurly)</a>
<a href="../engine/parser/Parser.cs.html#2894"><b>2894</b>if (configurationNameToken.Kind == <i>TokenKind</i>.EndOfInput)</a>
<a href="../engine/parser/Parser.cs.html#3064"><b>3064</b>if (lCurly.Kind != <i>TokenKind</i>.LCurly)</a>
<a href="../engine/parser/Parser.cs.html#3289"><b>3289</b>if (nameToken.Kind == <i>TokenKind</i>.EndOfInput)</a>
<a href="../engine/parser/Parser.cs.html#3338"><b>3338</b>while (foreachParameterToken.Kind == <i>TokenKind</i>.Parameter)</a>
<a href="../engine/parser/Parser.cs.html#3375"><b>3375</b>if (lParen.Kind != <i>TokenKind</i>.LParen)</a>
<a href="../engine/parser/Parser.cs.html#3391"><b>3391</b>if (token.Kind != <i>TokenKind</i>.Variable &amp;&amp; token.Kind != <i>TokenKind</i>.SplattedVariable)</a>
<a href="../engine/parser/Parser.cs.html#3409"><b>3409</b>if (inToken.Kind != <i>TokenKind</i>.In)</a>
<a href="../engine/parser/Parser.cs.html#3436"><b>3436</b>if (rParen.Kind != <i>TokenKind</i>.RParen)</a>
<a href="../engine/parser/Parser.cs.html#3499"><b>3499</b>if (lParen.Kind != <i>TokenKind</i>.LParen)</a>
<a href="../engine/parser/Parser.cs.html#3519"><b>3519</b>if (PeekToken().Kind == <i>TokenKind</i>.Semi)</a>
<a href="../engine/parser/Parser.cs.html#3531"><b>3531</b>if (PeekToken().Kind == <i>TokenKind</i>.Semi)</a>
<a href="../engine/parser/Parser.cs.html#3546"><b>3546</b>if (rParen.Kind != <i>TokenKind</i>.RParen)</a>
<a href="../engine/parser/Parser.cs.html#3596"><b>3596</b>if (lParen.Kind != <i>TokenKind</i>.LParen)</a>
<a href="../engine/parser/Parser.cs.html#3633"><b>3633</b>if (rParen.Kind != <i>TokenKind</i>.RParen)</a>
<a href="../engine/parser/Parser.cs.html#3747"><b>3747</b>if (nameToken.Kind == <i>TokenKind</i>.EndOfInput)</a>
<a href="../engine/parser/Parser.cs.html#3770"><b>3770</b>if (nameToken.Kind == <i>TokenKind</i>.LCurly)</a>
<a href="../engine/parser/Parser.cs.html#3782"><b>3782</b>else if (nameToken.Kind == <i>TokenKind</i>.Identifier || nameToken.Kind == <i>TokenKind</i>.DynamicKeyword)</a>
<a href="../engine/parser/Parser.cs.html#3877"><b>3877</b>if (lCurly.Kind == <i>TokenKind</i>.EndOfInput)</a>
<a href="../engine/parser/Parser.cs.html#3891"><b>3891</b>if (lCurly.Kind != <i>TokenKind</i>.LCurly)</a>
<a href="../engine/parser/Parser.cs.html#3922"><b>3922</b>if (lCurly.Kind == <i>TokenKind</i>.Dot &amp;&amp; originalInstanceName != null &amp;&amp; lCurly.Extent.StartOffset == originalInstanceName.Extent.EndOffset)</a>
<a href="../engine/parser/Parser.cs.html#4085"><b>4085</b><i>TokenKind</i>.Do.Text());</a>
<a href="../engine/parser/Parser.cs.html#4091"><b>4091</b>if (whileOrUntilToken.Kind != <i>TokenKind</i>.While &amp;&amp; whileOrUntilToken.Kind != <i>TokenKind</i>.Until)</a>
<a href="../engine/parser/Parser.cs.html#4105"><b>4105</b>if (lParen.Kind != <i>TokenKind</i>.LParen)</a>
<a href="../engine/parser/Parser.cs.html#4133"><b>4133</b>if (rParen.Kind != <i>TokenKind</i>.RParen)</a>
<a href="../engine/parser/Parser.cs.html#4160"><b>4160</b>if (whileOrUntilToken.Kind == <i>TokenKind</i>.Until)</a>
<a href="../engine/parser/Parser.cs.html#4221"><b>4221</b>if (colonToken.Kind == <i>TokenKind</i>.Colon)</a>
<a href="../engine/parser/Parser.cs.html#4242"><b>4242</b>if (commaToken.Kind == <i>TokenKind</i>.Comma)</a>
<a href="../engine/parser/Parser.cs.html#4255"><b>4255</b>if (lCurly.Kind != <i>TokenKind</i>.LCurly)</a>
<a href="../engine/parser/Parser.cs.html#4295"><b>4295</b>if (rCurly.Kind != <i>TokenKind</i>.RCurly)</a>
<a href="../engine/parser/Parser.cs.html#4459"><b>4459</b>case <i>TokenKind</i>.Hidden:</a>
<a href="../engine/parser/Parser.cs.html#4473"><b>4473</b>case <i>TokenKind</i>.Static:</a>
<a href="../engine/parser/Parser.cs.html#4493"><b>4493</b>if (token.Kind == <i>TokenKind</i>.Variable)</a>
<a href="../engine/parser/Parser.cs.html#4501"><b>4501</b>if (assignToken.Kind == <i>TokenKind</i>.Equals)</a>
<a href="../engine/parser/Parser.cs.html#4525"><b>4525</b>if (terminatorToken.Kind != <i>TokenKind</i>.NewLine &amp;&amp; terminatorToken.Kind != <i>TokenKind</i>.Semi &amp;&amp; terminatorToken.Kind != <i>TokenKind</i>.RCurly)</a>
<a href="../engine/parser/Parser.cs.html#4535"><b>4535</b>if (terminatorToken.Kind == <i>TokenKind</i>.Semi)</a>
<a href="../engine/parser/Parser.cs.html#4567"><b>4567</b>SyncOnError(false, <i>TokenKind</i>.RCurly);</a>
<a href="../engine/parser/Parser.cs.html#4606"><b>4606</b>if (token.Kind == <i>TokenKind</i>.Identifier</a>
<a href="../engine/parser/Parser.cs.html#4607"><b>4607</b>|| token.Kind == <i>TokenKind</i>.DynamicKeyword</a>
<a href="../engine/parser/Parser.cs.html#4656"><b>4656</b>if (typeName.Kind != <i>TokenKind</i>.Identifier)</a>
<a href="../engine/parser/Parser.cs.html#4706"><b>4706</b>if (colonToken.Kind == <i>TokenKind</i>.Colon)</a>
<a href="../engine/parser/Parser.cs.html#4737"><b>4737</b>if (lCurly.Kind != <i>TokenKind</i>.LCurly)</a>
<a href="../engine/parser/Parser.cs.html#4760"><b>4760</b>if (rCurly.Kind != <i>TokenKind</i>.RCurly)</a>
<a href="../engine/parser/Parser.cs.html#4820"><b>4820</b>if (assignToken.Kind == <i>TokenKind</i>.Equals)</a>
<a href="../engine/parser/Parser.cs.html#4845"><b>4845</b>if (terminatorToken.Kind != <i>TokenKind</i>.NewLine &amp;&amp; terminatorToken.Kind != <i>TokenKind</i>.Semi &amp;&amp; terminatorToken.Kind != <i>TokenKind</i>.RCurly)</a>
<a href="../engine/parser/Parser.cs.html#4859"><b>4859</b>if (terminatorToken.Kind == <i>TokenKind</i>.Semi)</a>
<a href="../engine/parser/Parser.cs.html#4889"><b>4889</b>case <i>TokenKind</i>.Namespace:</a>
<a href="../engine/parser/Parser.cs.html#4894"><b>4894</b>case <i>TokenKind</i>.Type:</a>
<a href="../engine/parser/Parser.cs.html#4899"><b>4899</b>case <i>TokenKind</i>.Module:</a>
<a href="../engine/parser/Parser.cs.html#4904"><b>4904</b>case <i>TokenKind</i>.Command:</a>
<a href="../engine/parser/Parser.cs.html#4909"><b>4909</b>case <i>TokenKind</i>.Assembly:</a>
<a href="../engine/parser/Parser.cs.html#4924"><b>4924</b>case <i>TokenKind</i>.EndOfInput:</a>
<a href="../engine/parser/Parser.cs.html#4925"><b>4925</b>case <i>TokenKind</i>.NewLine:</a>
<a href="../engine/parser/Parser.cs.html#4929"><b>4929</b>case <i>TokenKind</i>.Comma:</a>
<a href="../engine/parser/Parser.cs.html#4930"><b>4930</b>case <i>TokenKind</i>.Semi:</a>
<a href="../engine/parser/Parser.cs.html#4947"><b>4947</b>SyncOnError(true, <i>TokenKind</i>.Semi, <i>TokenKind</i>.NewLine);</a>
<a href="../engine/parser/Parser.cs.html#4976"><b>4976</b>if (equalsToken.Kind == <i>TokenKind</i>.Equals)</a>
<a href="../engine/parser/Parser.cs.html#4981"><b>4981</b>if (aliasToken.Kind == <i>TokenKind</i>.EndOfInput)</a>
<a href="../engine/parser/Parser.cs.html#5147"><b>5147</b>if (lParen.Kind == <i>TokenKind</i>.LParen)</a>
<a href="../engine/parser/Parser.cs.html#5172"><b>5172</b>if (colonToken.Kind == <i>TokenKind</i>.Colon)</a>
<a href="../engine/parser/Parser.cs.html#5177"><b>5177</b>if (baseToken.Kind == <i>TokenKind</i>.Base)</a>
<a href="../engine/parser/Parser.cs.html#5182"><b>5182</b>if (lParen.Kind == <i>TokenKind</i>.LParen)</a>
<a href="../engine/parser/Parser.cs.html#5222"><b>5222</b>if (lCurly.Kind != <i>TokenKind</i>.LCurly)</a>
<a href="../engine/parser/Parser.cs.html#5296"><b>5296</b>case <i>TokenKind</i>.Pipe:</a>
<a href="../engine/parser/Parser.cs.html#5297"><b>5297</b>case <i>TokenKind</i>.LParen:</a>
<a href="../engine/parser/Parser.cs.html#5298"><b>5298</b>case <i>TokenKind</i>.LCurly:</a>
<a href="../engine/parser/Parser.cs.html#5299"><b>5299</b>case <i>TokenKind</i>.AtParen:</a>
<a href="../engine/parser/Parser.cs.html#5300"><b>5300</b>case <i>TokenKind</i>.AtCurly:</a>
<a href="../engine/parser/Parser.cs.html#5301"><b>5301</b>case <i>TokenKind</i>.RCurly:</a>
<a href="../engine/parser/Parser.cs.html#5302"><b>5302</b>case <i>TokenKind</i>.RParen:</a>
<a href="../engine/parser/Parser.cs.html#5303"><b>5303</b>case <i>TokenKind</i>.EndOfInput:</a>
<a href="../engine/parser/Parser.cs.html#5304"><b>5304</b>case <i>TokenKind</i>.Semi:</a>
<a href="../engine/parser/Parser.cs.html#5305"><b>5305</b>case <i>TokenKind</i>.Redirection:</a>
<a href="../engine/parser/Parser.cs.html#5306"><b>5306</b>case <i>TokenKind</i>.RedirectInStd:</a>
<a href="../engine/parser/Parser.cs.html#5307"><b>5307</b>case <i>TokenKind</i>.AndAnd:</a>
<a href="../engine/parser/Parser.cs.html#5308"><b>5308</b>case <i>TokenKind</i>.OrOr:</a>
<a href="../engine/parser/Parser.cs.html#5309"><b>5309</b>case <i>TokenKind</i>.Ampersand:</a>
<a href="../engine/parser/Parser.cs.html#5310"><b>5310</b>case <i>TokenKind</i>.Variable:</a>
<a href="../engine/parser/Parser.cs.html#5311"><b>5311</b>case <i>TokenKind</i>.SplattedVariable:</a>
<a href="../engine/parser/Parser.cs.html#5312"><b>5312</b>case <i>TokenKind</i>.HereStringExpandable:</a>
<a href="../engine/parser/Parser.cs.html#5313"><b>5313</b>case <i>TokenKind</i>.HereStringLiteral:</a>
<a href="../engine/parser/Parser.cs.html#5314"><b>5314</b>case <i>TokenKind</i>.StringLiteral:</a>
<a href="../engine/parser/Parser.cs.html#5315"><b>5315</b>case <i>TokenKind</i>.StringExpandable:</a>
<a href="../engine/parser/Parser.cs.html#5334"><b>5334</b>if (lCurly.Kind != <i>TokenKind</i>.LCurly)</a>
<a href="../engine/parser/Parser.cs.html#5353"><b>5353</b>bool isFilter = functionToken.Kind == <i>TokenKind</i>.Filter;</a>
<a href="../engine/parser/Parser.cs.html#5354"><b>5354</b>bool isWorkflow = functionToken.Kind == <i>TokenKind</i>.Workflow;</a>
<a href="../engine/parser/Parser.cs.html#5362"><b>5362</b>var functionName = (functionNameToken.Kind == <i>TokenKind</i>.Generic)</a>
<a href="../engine/parser/Parser.cs.html#5386"><b>5386</b>if (lParen.Kind == <i>TokenKind</i>.LParen)</a>
<a href="../engine/parser/Parser.cs.html#5393"><b>5393</b>if (rParen.Kind != <i>TokenKind</i>.RParen)</a>
<a href="../engine/parser/Parser.cs.html#5465"><b>5465</b>if (catchToken.Kind != <i>TokenKind</i>.Catch)</a>
<a href="../engine/parser/Parser.cs.html#5516"><b>5516</b>if (commaToken.Kind != <i>TokenKind</i>.Comma)</a>
<a href="../engine/parser/Parser.cs.html#5599"><b>5599</b>if (finallyToken.Kind == <i>TokenKind</i>.Finally)</a>
<a href="../engine/parser/Parser.cs.html#5658"><b>5658</b>if (supportedCommandToken.Kind == <i>TokenKind</i>.Parameter)</a>
<a href="../engine/parser/Parser.cs.html#5698"><b>5698</b>if (commaToken.Kind == <i>TokenKind</i>.Comma)</a>
<a href="../engine/parser/Parser.cs.html#5848"><b>5848</b>case <i>TokenKind</i>.EndOfInput:</a>
<a href="../engine/parser/Parser.cs.html#5857"><b>5857</b>case <i>TokenKind</i>.Dot:</a>
<a href="../engine/parser/Parser.cs.html#5858"><b>5858</b>case <i>TokenKind</i>.Ampersand:</a>
<a href="../engine/parser/Parser.cs.html#5882"><b>5882</b>case <i>TokenKind</i>.AndAnd:</a>
<a href="../engine/parser/Parser.cs.html#5883"><b>5883</b>case <i>TokenKind</i>.OrOr:</a>
<a href="../engine/parser/Parser.cs.html#5889"><b>5889</b>case <i>TokenKind</i>.Ampersand:</a>
<a href="../engine/parser/Parser.cs.html#5895"><b>5895</b>case <i>TokenKind</i>.AndAnd:</a>
<a href="../engine/parser/Parser.cs.html#5896"><b>5896</b>case <i>TokenKind</i>.OrOr:</a>
<a href="../engine/parser/Parser.cs.html#5942"><b>5942</b>if (PeekToken().Kind == <i>TokenKind</i>.EndOfInput)</a>
<a href="../engine/parser/Parser.cs.html#6044"><b>6044</b>else if (pipelineElements.Count &gt; 0 || PeekToken().Kind == <i>TokenKind</i>.Pipe)</a>
<a href="../engine/parser/Parser.cs.html#6063"><b>6063</b>if (nextToken.Kind == <i>TokenKind</i>.NewLine &amp;&amp; _tokenizer.IsPipeContinuation(nextToken.Extent))</a>
<a href="../engine/parser/Parser.cs.html#6071"><b>6071</b>case <i>TokenKind</i>.Semi:</a>
<a href="../engine/parser/Parser.cs.html#6072"><b>6072</b>case <i>TokenKind</i>.NewLine:</a>
<a href="../engine/parser/Parser.cs.html#6073"><b>6073</b>case <i>TokenKind</i>.RParen:</a>
<a href="../engine/parser/Parser.cs.html#6074"><b>6074</b>case <i>TokenKind</i>.RCurly:</a>
<a href="../engine/parser/Parser.cs.html#6075"><b>6075</b>case <i>TokenKind</i>.EndOfInput:</a>
<a href="../engine/parser/Parser.cs.html#6080"><b>6080</b>case <i>TokenKind</i>.AndAnd:</a>
<a href="../engine/parser/Parser.cs.html#6081"><b>6081</b>case <i>TokenKind</i>.OrOr:</a>
<a href="../engine/parser/Parser.cs.html#6085"><b>6085</b>case <i>TokenKind</i>.Ampersand:</a>
<a href="../engine/parser/Parser.cs.html#6098"><b>6098</b>case <i>TokenKind</i>.Pipe:</a>
<a href="../engine/parser/Parser.cs.html#6101"><b>6101</b>if (PeekToken().Kind == <i>TokenKind</i>.EndOfInput)</a>
<a href="../engine/parser/Parser.cs.html#6238"><b>6238</b>if (PeekToken().Kind == <i>TokenKind</i>.Comma || PeekToken().Kind == <i>TokenKind</i>.EndOfInput)</a>
<a href="../engine/parser/Parser.cs.html#6267"><b>6267</b>Diagnostics.Assert(token.Kind != <i>TokenKind</i>.Comma, &quot;A unary comma is an error in command mode, and should have already been reported.&quot;);</a>
<a href="../engine/parser/Parser.cs.html#6278"><b>6278</b>case <i>TokenKind</i>.Pipe:</a>
<a href="../engine/parser/Parser.cs.html#6279"><b>6279</b>case <i>TokenKind</i>.RCurly:</a>
<a href="../engine/parser/Parser.cs.html#6280"><b>6280</b>case <i>TokenKind</i>.RParen:</a>
<a href="../engine/parser/Parser.cs.html#6281"><b>6281</b>case <i>TokenKind</i>.EndOfInput:</a>
<a href="../engine/parser/Parser.cs.html#6282"><b>6282</b>case <i>TokenKind</i>.NewLine:</a>
<a href="../engine/parser/Parser.cs.html#6283"><b>6283</b>case <i>TokenKind</i>.Semi:</a>
<a href="../engine/parser/Parser.cs.html#6284"><b>6284</b>case <i>TokenKind</i>.Redirection:</a>
<a href="../engine/parser/Parser.cs.html#6285"><b>6285</b>case <i>TokenKind</i>.RedirectInStd:</a>
<a href="../engine/parser/Parser.cs.html#6286"><b>6286</b>case <i>TokenKind</i>.AndAnd:</a>
<a href="../engine/parser/Parser.cs.html#6287"><b>6287</b>case <i>TokenKind</i>.OrOr:</a>
<a href="../engine/parser/Parser.cs.html#6288"><b>6288</b>case <i>TokenKind</i>.Ampersand:</a>
<a href="../engine/parser/Parser.cs.html#6289"><b>6289</b>case <i>TokenKind</i>.MinusMinus:</a>
<a href="../engine/parser/Parser.cs.html#6290"><b>6290</b>case <i>TokenKind</i>.Comma:</a>
<a href="../engine/parser/Parser.cs.html#6308"><b>6308</b>case <i>TokenKind</i>.SplattedVariable:</a>
<a href="../engine/parser/Parser.cs.html#6309"><b>6309</b>case <i>TokenKind</i>.Variable:</a>
<a href="../engine/parser/Parser.cs.html#6310"><b>6310</b>case <i>TokenKind</i>.Number:</a>
<a href="../engine/parser/Parser.cs.html#6311"><b>6311</b>case <i>TokenKind</i>.HereStringExpandable:</a>
<a href="../engine/parser/Parser.cs.html#6312"><b>6312</b>case <i>TokenKind</i>.StringExpandable:</a>
<a href="../engine/parser/Parser.cs.html#6313"><b>6313</b>case <i>TokenKind</i>.HereStringLiteral:</a>
<a href="../engine/parser/Parser.cs.html#6314"><b>6314</b>case <i>TokenKind</i>.StringLiteral:</a>
<a href="../engine/parser/Parser.cs.html#6315"><b>6315</b>case <i>TokenKind</i>.LParen:</a>
<a href="../engine/parser/Parser.cs.html#6316"><b>6316</b>case <i>TokenKind</i>.DollarParen:</a>
<a href="../engine/parser/Parser.cs.html#6317"><b>6317</b>case <i>TokenKind</i>.AtParen:</a>
<a href="../engine/parser/Parser.cs.html#6318"><b>6318</b>case <i>TokenKind</i>.AtCurly:</a>
<a href="../engine/parser/Parser.cs.html#6319"><b>6319</b>case <i>TokenKind</i>.LCurly:</a>
<a href="../engine/parser/Parser.cs.html#6325"><b>6325</b>case <i>TokenKind</i>.Generic:</a>
<a href="../engine/parser/Parser.cs.html#6387"><b>6387</b>if (token.Kind != <i>TokenKind</i>.Comma)</a>
<a href="../engine/parser/Parser.cs.html#6465"><b>6465</b>if (token.Kind == <i>TokenKind</i>.Dot)</a>
<a href="../engine/parser/Parser.cs.html#6471"><b>6471</b>else if (token.Kind == <i>TokenKind</i>.Ampersand)</a>
<a href="../engine/parser/Parser.cs.html#6487"><b>6487</b>case <i>TokenKind</i>.Pipe:</a>
<a href="../engine/parser/Parser.cs.html#6488"><b>6488</b>case <i>TokenKind</i>.RCurly:</a>
<a href="../engine/parser/Parser.cs.html#6489"><b>6489</b>case <i>TokenKind</i>.RParen:</a>
<a href="../engine/parser/Parser.cs.html#6490"><b>6490</b>case <i>TokenKind</i>.EndOfInput:</a>
<a href="../engine/parser/Parser.cs.html#6491"><b>6491</b>case <i>TokenKind</i>.NewLine:</a>
<a href="../engine/parser/Parser.cs.html#6492"><b>6492</b>case <i>TokenKind</i>.Semi:</a>
<a href="../engine/parser/Parser.cs.html#6493"><b>6493</b>case <i>TokenKind</i>.AndAnd:</a>
<a href="../engine/parser/Parser.cs.html#6494"><b>6494</b>case <i>TokenKind</i>.OrOr:</a>
<a href="../engine/parser/Parser.cs.html#6495"><b>6495</b>case <i>TokenKind</i>.Ampersand:</a>
<a href="../engine/parser/Parser.cs.html#6500"><b>6500</b>case <i>TokenKind</i>.MinusMinus:</a>
<a href="../engine/parser/Parser.cs.html#6510"><b>6510</b>case <i>TokenKind</i>.Comma:</a>
<a href="../engine/parser/Parser.cs.html#6518"><b>6518</b>case <i>TokenKind</i>.Parameter:</a>
<a href="../engine/parser/Parser.cs.html#6533"><b>6533</b>if (parameterToken.UsedColon &amp;&amp; PeekToken().Kind != <i>TokenKind</i>.Comma)</a>
<a href="../engine/parser/Parser.cs.html#6560"><b>6560</b>case <i>TokenKind</i>.Redirection:</a>
<a href="../engine/parser/Parser.cs.html#6561"><b>6561</b>case <i>TokenKind</i>.RedirectInStd:</a>
<a href="../engine/parser/Parser.cs.html#6584"><b>6584</b>if (token.Kind == <i>TokenKind</i>.InlineScript &amp;&amp; context == CommandArgumentContext.CommandName)</a>
<a href="../engine/parser/Parser.cs.html#6658"><b>6658</b>dotSource || ampersand ? firstToken.Kind : <i>TokenKind</i>.Unknown,</a>
<a href="../engine/parser/Parser.cs.html#6698"><b>6698</b>if (token.Kind != <i>TokenKind</i>.QuestionMark)</a>
<a href="../engine/parser/Parser.cs.html#6724"><b>6724</b>if (token.Kind != <i>TokenKind</i>.Colon)</a>
<a href="../engine/parser/Parser.cs.html#6840"><b>6840</b>else if (token.Kind == <i>TokenKind</i>.AndAnd || token.Kind == <i>TokenKind</i>.OrOr)</a>
<a href="../engine/parser/Parser.cs.html#6965"><b>6965</b>if (commaToken.Kind != <i>TokenKind</i>.Comma || _disableCommaOperator)</a>
<a href="../engine/parser/Parser.cs.html#6972"><b>6972</b>while (commaToken.Kind == <i>TokenKind</i>.Comma)</a>
<a href="../engine/parser/Parser.cs.html#7045"><b>7045</b>bool needResync = _ungotToken.Kind == <i>TokenKind</i>.Minus;</a>
<a href="../engine/parser/Parser.cs.html#7050"><b>7050</b>needResync = endNumberOnTernaryOpChars &amp;&amp; _ungotToken.Kind == <i>TokenKind</i>.Generic;</a>
<a href="../engine/parser/Parser.cs.html#7070"><b>7070</b>if (_disableCommaOperator &amp;&amp; token.Kind == <i>TokenKind</i>.Comma)</a>
<a href="../engine/parser/Parser.cs.html#7082"><b>7082</b>if (token.Kind == <i>TokenKind</i>.Comma)</a>
<a href="../engine/parser/Parser.cs.html#7107"><b>7107</b>else if (token.Kind == <i>TokenKind</i>.LBracket)</a>
<a href="../engine/parser/Parser.cs.html#7156"><b>7156</b>if (token.Kind != <i>TokenKind</i>.NewLine &amp;&amp; token.Kind != <i>TokenKind</i>.Comma)</a>
<a href="../engine/parser/Parser.cs.html#7192"><b>7192</b><i>TokenKind</i> operation = (token.Kind == <i>TokenKind</i>.PlusPlus)</a>
<a href="../engine/parser/Parser.cs.html#7193"><b>7193</b>? <i>TokenKind</i>.PostfixPlusPlus</a>
<a href="../engine/parser/Parser.cs.html#7194"><b>7194</b>: (token.Kind == <i>TokenKind</i>.MinusMinus)</a>
<a href="../engine/parser/Parser.cs.html#7195"><b>7195</b>? <i>TokenKind</i>.PostfixMinusMinus</a>
<a href="../engine/parser/Parser.cs.html#7196"><b>7196</b>: <i>TokenKind</i>.Unknown;</a>
<a href="../engine/parser/Parser.cs.html#7197"><b>7197</b>if (operation != <i>TokenKind</i>.Unknown)</a>
<a href="../engine/parser/Parser.cs.html#7231"><b>7231</b>case <i>TokenKind</i>.SplattedVariable:</a>
<a href="../engine/parser/Parser.cs.html#7232"><b>7232</b>case <i>TokenKind</i>.Variable:</a>
<a href="../engine/parser/Parser.cs.html#7236"><b>7236</b>case <i>TokenKind</i>.Number:</a>
<a href="../engine/parser/Parser.cs.html#7240"><b>7240</b>case <i>TokenKind</i>.HereStringExpandable:</a>
<a href="../engine/parser/Parser.cs.html#7241"><b>7241</b>case <i>TokenKind</i>.StringExpandable:</a>
<a href="../engine/parser/Parser.cs.html#7245"><b>7245</b>case <i>TokenKind</i>.HereStringLiteral:</a>
<a href="../engine/parser/Parser.cs.html#7246"><b>7246</b>case <i>TokenKind</i>.StringLiteral:</a>
<a href="../engine/parser/Parser.cs.html#7250"><b>7250</b>case <i>TokenKind</i>.LParen:</a>
<a href="../engine/parser/Parser.cs.html#7254"><b>7254</b>case <i>TokenKind</i>.AtParen:</a>
<a href="../engine/parser/Parser.cs.html#7255"><b>7255</b>case <i>TokenKind</i>.DollarParen:</a>
<a href="../engine/parser/Parser.cs.html#7259"><b>7259</b>case <i>TokenKind</i>.AtCurly:</a>
<a href="../engine/parser/Parser.cs.html#7263"><b>7263</b>case <i>TokenKind</i>.LCurly:</a>
<a href="../engine/parser/Parser.cs.html#7286"><b>7286</b>ExpressionAst childExpr = new VariableExpressionAst(variableToken.Extent, realVariablePath, (variableToken.Kind == <i>TokenKind</i>.SplattedVariable));</a>
<a href="../engine/parser/Parser.cs.html#7305"><b>7305</b>if (token.Kind == <i>TokenKind</i>.Dot || token.Kind == <i>TokenKind</i>.ColonColon || token.Kind == <i>TokenKind</i>.QuestionDot)</a>
<a href="../engine/parser/Parser.cs.html#7309"><b>7309</b>else if (token.Kind == <i>TokenKind</i>.LBracket || token.Kind == <i>TokenKind</i>.QuestionLBracket)</a>
<a href="../engine/parser/Parser.cs.html#7345"><b>7345</b>if (token.Kind != <i>TokenKind</i>.NewLine &amp;&amp; token.Kind != <i>TokenKind</i>.Semi)</a>
<a href="../engine/parser/Parser.cs.html#7355"><b>7355</b>if (rCurly.Kind != <i>TokenKind</i>.RCurly)</a>
<a href="../engine/parser/Parser.cs.html#7409"><b>7409</b>if (equals.Kind != <i>TokenKind</i>.Equals)</a>
<a href="../engine/parser/Parser.cs.html#7430"><b>7430</b>SyncOnError(false, <i>TokenKind</i>.RCurly, <i>TokenKind</i>.Semi, <i>TokenKind</i>.NewLine);</a>
<a href="../engine/parser/Parser.cs.html#7521"><b>7521</b>if (rParen.Kind != <i>TokenKind</i>.RParen)</a>
<a href="../engine/parser/Parser.cs.html#7539"><b>7539</b>rParen.Kind == <i>TokenKind</i>.RParen ? rParen.Extent : statementListExtent ?? firstToken.Extent);</a>
<a href="../engine/parser/Parser.cs.html#7540"><b>7540</b>if (firstToken.Kind == <i>TokenKind</i>.DollarParen)</a>
<a href="../engine/parser/Parser.cs.html#7547"><b>7547</b>Diagnostics.Assert(firstToken.Kind == <i>TokenKind</i>.AtParen, &quot;only support $() and @() here.&quot;);</a>
<a href="../engine/parser/Parser.cs.html#7580"><b>7580</b>if (rParen.Kind != <i>TokenKind</i>.RParen)</a>
<a href="../engine/parser/Parser.cs.html#7689"><b>7689</b>if (token.Kind.HasTrait(TokenFlags.UnaryOperator) || token.Kind == <i>TokenKind</i>.LBracket)</a>
<a href="../engine/parser/Parser.cs.html#7723"><b>7723</b>Diagnostics.Assert(lParen.Kind == <i>TokenKind</i>.LParen || lParen.Kind == <i>TokenKind</i>.LCurly, &quot;token kind incorrect&quot;);</a>
<a href="../engine/parser/Parser.cs.html#7734"><b>7734</b>@static: operatorToken.Kind == <i>TokenKind</i>.ColonColon,</a>
<a href="../engine/parser/Parser.cs.html#7735"><b>7735</b>nullConditional: operatorToken.Kind == <i>TokenKind</i>.QuestionDot);</a>
<a href="../engine/parser/Parser.cs.html#7749"><b>7749</b>if (lBracket.Kind == <i>TokenKind</i>.LParen)</a>
<a href="../engine/parser/Parser.cs.html#7768"><b>7768</b>operatorToken.Kind == <i>TokenKind</i>.ColonColon,</a>
<a href="../engine/parser/Parser.cs.html#7769"><b>7769</b>operatorToken.Kind == <i>TokenKind</i>.QuestionDot);</a>
<a href="../engine/parser/Parser.cs.html#7808"><b>7808</b><i>TokenKind</i>.Comma.Text());</a>
<a href="../engine/parser/Parser.cs.html#7819"><b>7819</b>if (comma.Kind != <i>TokenKind</i>.Comma)</a>
<a href="../engine/parser/Parser.cs.html#7829"><b>7829</b>if (rParen.Kind != <i>TokenKind</i>.RParen)</a>
<a href="../engine/parser/Parser.cs.html#7875"><b>7875</b>if (rBracket.Kind != <i>TokenKind</i>.RBracket)</a>
<a href="../engine/parser/Parser.cs.html#7891"><b>7891</b>return new IndexExpressionAst(ExtentOf(primaryExpression, ExtentFromFirstOf(rBracket, indexExpr)), primaryExpression, indexExpr, lBracket.Kind == <i>TokenKind</i>.QuestionLBracket);</a>
</div>
<div class="rF"><div class="rN">engine\parser\SemanticChecks.cs (10)</div>
<a href="../engine/parser/SemanticChecks.cs.html#867"><b>867</b>CheckAssignmentTarget(assignmentStatementAst.Left, assignmentStatementAst.Operator == <i>TokenKind</i>.Equals,</a>
<a href="../engine/parser/SemanticChecks.cs.html#877"><b>877</b>if (binaryExpressionAst.Operator == <i>TokenKind</i>.AndAnd</a>
<a href="../engine/parser/SemanticChecks.cs.html#878"><b>878</b>|| binaryExpressionAst.Operator == <i>TokenKind</i>.OrOr)</a>
<a href="../engine/parser/SemanticChecks.cs.html#893"><b>893</b>case <i>TokenKind</i>.PlusPlus:</a>
<a href="../engine/parser/SemanticChecks.cs.html#894"><b>894</b>case <i>TokenKind</i>.PostfixPlusPlus:</a>
<a href="../engine/parser/SemanticChecks.cs.html#895"><b>895</b>case <i>TokenKind</i>.MinusMinus:</a>
<a href="../engine/parser/SemanticChecks.cs.html#896"><b>896</b>case <i>TokenKind</i>.PostfixMinusMinus:</a>
<a href="../engine/parser/SemanticChecks.cs.html#2103"><b>2103</b>if (commandAst.InvocationOperator == <i>TokenKind</i>.Dot)</a>
<a href="../engine/parser/SemanticChecks.cs.html#2117"><b>2117</b>if (commandAst.InvocationOperator == <i>TokenKind</i>.Ampersand)</a>
<a href="../engine/parser/SemanticChecks.cs.html#2122"><b>2122</b><i>TokenKind</i>.Ampersand.Text());</a>
</div>
<div class="rF"><div class="rN">engine\parser\token.cs (30)</div>
<a href="../engine/parser/token.cs.html#1157"><b>1157</b>Diagnostics.Assert(s_staticTokenFlags.Length == ((int)<i>TokenKind</i>.Default + 1),</a>
<a href="../engine/parser/token.cs.html#1159"><b>1159</b>Diagnostics.Assert(s_tokenText.Length == ((int)<i>TokenKind</i>.Default + 1),</a>
<a href="../engine/parser/token.cs.html#1162"><b>1162</b>Diagnostics.Assert(GetTraits(<i>TokenKind</i>.Begin) == (TokenFlags.Keyword | TokenFlags.ScriptBlockBlockName),</a>
<a href="../engine/parser/token.cs.html#1164"><b>1164</b>Diagnostics.Assert(GetTraits(<i>TokenKind</i>.Workflow) == (TokenFlags.Keyword | TokenFlags.StatementDoesntSupportAttributes),</a>
<a href="../engine/parser/token.cs.html#1166"><b>1166</b>Diagnostics.Assert(GetTraits(<i>TokenKind</i>.Sequence) == (TokenFlags.Keyword | TokenFlags.StatementDoesntSupportAttributes),</a>
<a href="../engine/parser/token.cs.html#1168"><b>1168</b>Diagnostics.Assert(GetTraits(<i>TokenKind</i>.Shr) == (TokenFlags.BinaryOperator | TokenFlags.BinaryPrecedenceComparison | TokenFlags.CanConstantFold),</a>
<a href="../engine/parser/token.cs.html#1170"><b>1170</b>Diagnostics.Assert(s_tokenText[(int)<i>TokenKind</i>.Shr].Equals(&quot;-shr&quot;, StringComparison.OrdinalIgnoreCase),</a>
<a href="../engine/parser/token.cs.html#1178"><b>1178</b>public static TokenFlags GetTraits(this <i>TokenKind</i> kind)</a>
<a href="../engine/parser/token.cs.html#1186"><b>1186</b>public static bool HasTrait(this <i>TokenKind</i> kind, TokenFlags flag)</a>
<a href="../engine/parser/token.cs.html#1191"><b>1191</b>internal static int GetBinaryPrecedence(this <i>TokenKind</i> kind)</a>
<a href="../engine/parser/token.cs.html#1200"><b>1200</b>public static string Text(this <i>TokenKind</i> kind)</a>
<a href="../engine/parser/token.cs.html#1211"><b>1211</b>private <i>TokenKind</i> _kind;</a>
<a href="../engine/parser/token.cs.html#1215"><b>1215</b>internal Token(InternalScriptExtent scriptExtent, <i>TokenKind</i> kind, TokenFlags tokenFlags)</a>
<a href="../engine/parser/token.cs.html#1226"><b>1226</b>if (_kind != <i>TokenKind</i>.Identifier)</a>
<a href="../engine/parser/token.cs.html#1228"><b>1228</b>_kind = <i>TokenKind</i>.Generic;</a>
<a href="../engine/parser/token.cs.html#1245"><b>1245</b>public <i>TokenKind</i> Kind { get { return _kind; } }</a>
<a href="../engine/parser/token.cs.html#1262"><b>1262</b>return (_kind == <i>TokenKind</i>.EndOfInput) ? &quot;&lt;eof&gt;&quot; : Text;</a>
<a href="../engine/parser/token.cs.html#1279"><b>1279</b>: base(scriptExtent, <i>TokenKind</i>.Number, tokenFlags)</a>
<a href="../engine/parser/token.cs.html#1305"><b>1305</b>: base(scriptExtent, <i>TokenKind</i>.Parameter, TokenFlags.None)</a>
<a href="../engine/parser/token.cs.html#1339"><b>1339</b>: base(scriptExtent, splatted ? <i>TokenKind</i>.SplattedVariable : <i>TokenKind</i>.Variable, tokenFlags)</a>
<a href="../engine/parser/token.cs.html#1366"><b>1366</b>internal StringToken(InternalScriptExtent scriptExtent, <i>TokenKind</i> kind, TokenFlags tokenFlags, string value)</a>
<a href="../engine/parser/token.cs.html#1389"><b>1389</b>internal StringLiteralToken(InternalScriptExtent scriptExtent, TokenFlags flags, <i>TokenKind</i> tokenKind, string value)</a>
<a href="../engine/parser/token.cs.html#1402"><b>1402</b>internal StringExpandableToken(InternalScriptExtent scriptExtent, <i>TokenKind</i> tokenKind, string value, string formatString, List&lt;Token&gt; nestedTokens, TokenFlags flags)</a>
<a href="../engine/parser/token.cs.html#1459"><b>1459</b>: base(scriptExtent, <i>TokenKind</i>.Label, tokenFlags)</a>
<a href="../engine/parser/token.cs.html#1474"><b>1474</b>internal RedirectionToken(InternalScriptExtent scriptExtent, <i>TokenKind</i> kind)</a>
<a href="../engine/parser/token.cs.html#1486"><b>1486</b>: base(scriptExtent, <i>TokenKind</i>.RedirectInStd)</a>
<a href="../engine/parser/token.cs.html#1497"><b>1497</b>: base(scriptExtent, <i>TokenKind</i>.Redirection)</a>
<a href="../engine/parser/token.cs.html#1520"><b>1520</b>: base(scriptExtent, <i>TokenKind</i>.Redirection)</a>
<a href="../engine/parser/token.cs.html#1540"><b>1540</b>: base(scriptExtent, tokenFlags, <i>TokenKind</i>.StringLiteral, value)</a>
</div>
<div class="rF"><div class="rN">engine\parser\tokenizer.cs (205)</div>
<a href="../engine/parser/tokenizer.cs.html#597"><b>597</b>private static readonly Dictionary&lt;string, <i>TokenKind</i>&gt; s_keywordTable</a>
<a href="../engine/parser/tokenizer.cs.html#598"><b>598</b>= new Dictionary&lt;string, <i>TokenKind</i>&gt;(StringComparer.OrdinalIgnoreCase);</a>
<a href="../engine/parser/tokenizer.cs.html#600"><b>600</b>private static readonly Dictionary&lt;string, <i>TokenKind</i>&gt; s_operatorTable</a>
<a href="../engine/parser/tokenizer.cs.html#601"><b>601</b>= new Dictionary&lt;string, <i>TokenKind</i>&gt;(StringComparer.OrdinalIgnoreCase);</a>
<a href="../engine/parser/tokenizer.cs.html#641"><b>641</b>private static readonly <i>TokenKind</i>[] s_keywordTokenKind = new <i>TokenKind</i>[] {</a>
<a href="../engine/parser/tokenizer.cs.html#642"><b>642</b>/*1*/    <i>TokenKind</i>.ElseIf,          <i>TokenKind</i>.If,       <i>TokenKind</i>.Else,      <i>TokenKind</i>.Switch,            /*1*/</a>
<a href="../engine/parser/tokenizer.cs.html#643"><b>643</b>/*2*/    <i>TokenKind</i>.Foreach,         <i>TokenKind</i>.From,     <i>TokenKind</i>.In,        <i>TokenKind</i>.For,               /*2*/</a>
<a href="../engine/parser/tokenizer.cs.html#644"><b>644</b>/*3*/    <i>TokenKind</i>.While,           <i>TokenKind</i>.Until,    <i>TokenKind</i>.Do,        <i>TokenKind</i>.Try,               /*3*/</a>
<a href="../engine/parser/tokenizer.cs.html#645"><b>645</b>/*4*/    <i>TokenKind</i>.Catch,           <i>TokenKind</i>.Finally,  <i>TokenKind</i>.Trap,      <i>TokenKind</i>.Data,              /*4*/</a>
<a href="../engine/parser/tokenizer.cs.html#646"><b>646</b>/*5*/    <i>TokenKind</i>.Return,          <i>TokenKind</i>.Continue, <i>TokenKind</i>.Break,     <i>TokenKind</i>.Exit,              /*5*/</a>
<a href="../engine/parser/tokenizer.cs.html#647"><b>647</b>/*6*/    <i>TokenKind</i>.Throw,           <i>TokenKind</i>.Begin,    <i>TokenKind</i>.Process,   <i>TokenKind</i>.End,               /*6*/</a>
<a href="../engine/parser/tokenizer.cs.html#648"><b>648</b>/*7*/    <i>TokenKind</i>.Dynamicparam,    <i>TokenKind</i>.Function, <i>TokenKind</i>.Filter,    <i>TokenKind</i>.Param,             /*7*/</a>
<a href="../engine/parser/tokenizer.cs.html#649"><b>649</b>/*8*/    <i>TokenKind</i>.Class,           <i>TokenKind</i>.Define,   <i>TokenKind</i>.Var,       <i>TokenKind</i>.Using,             /*8*/</a>
<a href="../engine/parser/tokenizer.cs.html#650"><b>650</b>/*9*/    <i>TokenKind</i>.Workflow,        <i>TokenKind</i>.Parallel, <i>TokenKind</i>.Sequence,  <i>TokenKind</i>.InlineScript,      /*9*/</a>
<a href="../engine/parser/tokenizer.cs.html#651"><b>651</b>/*A*/    <i>TokenKind</i>.Configuration,   <i>TokenKind</i>.Public,   <i>TokenKind</i>.Private,   <i>TokenKind</i>.Static,            /*A*/</a>
<a href="../engine/parser/tokenizer.cs.html#652"><b>652</b>/*B*/    <i>TokenKind</i>.Interface,       <i>TokenKind</i>.Enum,     <i>TokenKind</i>.Namespace, <i>TokenKind</i>.Module,            /*B*/</a>
<a href="../engine/parser/tokenizer.cs.html#653"><b>653</b>/*C*/    <i>TokenKind</i>.Type,            <i>TokenKind</i>.Assembly, <i>TokenKind</i>.Command,   <i>TokenKind</i>.Hidden,            /*C*/</a>
<a href="../engine/parser/tokenizer.cs.html#654"><b>654</b>/*D*/    <i>TokenKind</i>.Base,            <i>TokenKind</i>.Default,                                                    /*D*/</a>
<a href="../engine/parser/tokenizer.cs.html#676"><b>676</b>private static readonly <i>TokenKind</i>[] s_operatorTokenKind = new <i>TokenKind</i>[] {</a>
<a href="../engine/parser/tokenizer.cs.html#677"><b>677</b>/*1*/   <i>TokenKind</i>.Bnot,         <i>TokenKind</i>.Not,          <i>TokenKind</i>.Ieq,          <i>TokenKind</i>.Ieq,            /*1*/</a>
<a href="../engine/parser/tokenizer.cs.html#678"><b>678</b>/*2*/   <i>TokenKind</i>.Ceq,          <i>TokenKind</i>.Ine,          <i>TokenKind</i>.Ine,          <i>TokenKind</i>.Cne,            /*2*/</a>
<a href="../engine/parser/tokenizer.cs.html#679"><b>679</b>/*3*/   <i>TokenKind</i>.Ige,          <i>TokenKind</i>.Ige,          <i>TokenKind</i>.Cge,          <i>TokenKind</i>.Igt,            /*3*/</a>
<a href="../engine/parser/tokenizer.cs.html#680"><b>680</b>/*4*/   <i>TokenKind</i>.Igt,          <i>TokenKind</i>.Cgt,          <i>TokenKind</i>.Ilt,          <i>TokenKind</i>.Ilt,            /*4*/</a>
<a href="../engine/parser/tokenizer.cs.html#681"><b>681</b>/*5*/   <i>TokenKind</i>.Clt,          <i>TokenKind</i>.Ile,          <i>TokenKind</i>.Ile,          <i>TokenKind</i>.Cle,            /*5*/</a>
<a href="../engine/parser/tokenizer.cs.html#682"><b>682</b>/*6*/   <i>TokenKind</i>.Ilike,        <i>TokenKind</i>.Ilike,        <i>TokenKind</i>.Clike,        <i>TokenKind</i>.Inotlike,       /*6*/</a>
<a href="../engine/parser/tokenizer.cs.html#683"><b>683</b>/*7*/   <i>TokenKind</i>.Inotlike,     <i>TokenKind</i>.Cnotlike,     <i>TokenKind</i>.Imatch,       <i>TokenKind</i>.Imatch,         /*7*/</a>
<a href="../engine/parser/tokenizer.cs.html#684"><b>684</b>/*8*/   <i>TokenKind</i>.Cmatch,       <i>TokenKind</i>.Inotmatch,    <i>TokenKind</i>.Inotmatch,    <i>TokenKind</i>.Cnotmatch,      /*8*/</a>
<a href="../engine/parser/tokenizer.cs.html#685"><b>685</b>/*9*/   <i>TokenKind</i>.Ireplace,     <i>TokenKind</i>.Ireplace,     <i>TokenKind</i>.Creplace,     <i>TokenKind</i>.Icontains,      /*9*/</a>
<a href="../engine/parser/tokenizer.cs.html#686"><b>686</b>/*10*/  <i>TokenKind</i>.Icontains,    <i>TokenKind</i>.Ccontains,    <i>TokenKind</i>.Inotcontains, <i>TokenKind</i>.Inotcontains,   /*10*/</a>
<a href="../engine/parser/tokenizer.cs.html#687"><b>687</b>/*11*/  <i>TokenKind</i>.Cnotcontains, <i>TokenKind</i>.Iin,          <i>TokenKind</i>.Iin,          <i>TokenKind</i>.Cin,            /*11*/</a>
<a href="../engine/parser/tokenizer.cs.html#688"><b>688</b>/*12*/  <i>TokenKind</i>.Inotin,       <i>TokenKind</i>.Inotin,       <i>TokenKind</i>.Cnotin,       <i>TokenKind</i>.Isplit,         /*12*/</a>
<a href="../engine/parser/tokenizer.cs.html#689"><b>689</b>/*13*/  <i>TokenKind</i>.Isplit,       <i>TokenKind</i>.Csplit,       <i>TokenKind</i>.IsNot,        <i>TokenKind</i>.Is,             /*13*/</a>
<a href="../engine/parser/tokenizer.cs.html#690"><b>690</b>/*14*/  <i>TokenKind</i>.As,           <i>TokenKind</i>.Format,       <i>TokenKind</i>.And,          <i>TokenKind</i>.Band,           /*14*/</a>
<a href="../engine/parser/tokenizer.cs.html#691"><b>691</b>/*15*/  <i>TokenKind</i>.Or,           <i>TokenKind</i>.Bor,          <i>TokenKind</i>.Xor,          <i>TokenKind</i>.Bxor,           /*15*/</a>
<a href="../engine/parser/tokenizer.cs.html#692"><b>692</b>/*16*/  <i>TokenKind</i>.Join,         <i>TokenKind</i>.Shl,          <i>TokenKind</i>.Shr,                                    /*16*/</a>
<a href="../engine/parser/tokenizer.cs.html#720"><b>720</b>Diagnostics.Assert(s_keywordTable[&quot;using&quot;] == <i>TokenKind</i>.Using, &quot;Keyword table out of sync w/ enum&quot;);</a>
<a href="../engine/parser/tokenizer.cs.html#721"><b>721</b>Diagnostics.Assert(s_operatorTable[&quot;join&quot;] == <i>TokenKind</i>.Join, &quot;Operator table out of sync w/ enum&quot;);</a>
<a href="../engine/parser/tokenizer.cs.html#998"><b>998</b>NewToken(<i>TokenKind</i>.NewLine);</a>
<a href="../engine/parser/tokenizer.cs.html#1009"><b>1009</b>NewToken(<i>TokenKind</i>.Semi);</a>
<a href="../engine/parser/tokenizer.cs.html#1021"><b>1021</b>NewToken(<i>TokenKind</i>.LineContinuation);</a>
<a href="../engine/parser/tokenizer.cs.html#1085"><b>1085</b>if (i &gt;= 0 &amp;&amp; tokenList[i].Kind == <i>TokenKind</i>.EndOfInput)</a>
<a href="../engine/parser/tokenizer.cs.html#1216"><b>1216</b>return SaveToken(new Token(CurrentExtent(), <i>TokenKind</i>.Comment, TokenFlags.None));</a>
<a href="../engine/parser/tokenizer.cs.html#1230"><b>1230</b>case <i>TokenKind</i>.NewLine:</a>
<a href="../engine/parser/tokenizer.cs.html#1231"><b>1231</b>case <i>TokenKind</i>.LineContinuation:</a>
<a href="../engine/parser/tokenizer.cs.html#1232"><b>1232</b>case <i>TokenKind</i>.Comment:</a>
<a href="../engine/parser/tokenizer.cs.html#1233"><b>1233</b>case <i>TokenKind</i>.EndOfInput:</a>
<a href="../engine/parser/tokenizer.cs.html#1249"><b>1249</b>private Token NewToken(<i>TokenKind</i> kind)</a>
<a href="../engine/parser/tokenizer.cs.html#1269"><b>1269</b>private StringToken NewStringLiteralToken(string value, <i>TokenKind</i> tokenKind, TokenFlags flags)</a>
<a href="../engine/parser/tokenizer.cs.html#1274"><b>1274</b>private StringToken NewStringExpandableToken(string value, string formatString, <i>TokenKind</i> tokenKind, List&lt;Token&gt; nestedTokens, TokenFlags flags)</a>
<a href="../engine/parser/tokenizer.cs.html#1293"><b>1293</b>return NewStringExpandableToken(value, formatString, <i>TokenKind</i>.Generic, nestedTokens, TokenFlags.None);</a>
<a href="../engine/parser/tokenizer.cs.html#1298"><b>1298</b>return NewStringLiteralToken(value, <i>TokenKind</i>.Generic, TokenFlags.None);</a>
<a href="../engine/parser/tokenizer.cs.html#2330"><b>2330</b>return NewStringLiteralToken(tokenValue, <i>TokenKind</i>.Generic, TokenFlags.None);</a>
<a href="../engine/parser/tokenizer.cs.html#2375"><b>2375</b>return NewStringLiteralToken(GetStringAndRelease(sb), <i>TokenKind</i>.StringLiteral, flags);</a>
<a href="../engine/parser/tokenizer.cs.html#2591"><b>2591</b>return NewStringExpandableToken(GetStringAndRelease(sb), GetStringAndRelease(formatSb), <i>TokenKind</i>.StringExpandable, nestedTokens, flags);</a>
<a href="../engine/parser/tokenizer.cs.html#2710"><b>2710</b>return NewStringLiteralToken(string.Empty, <i>TokenKind</i>.HereStringLiteral, TokenFlags.TokenInError);</a>
<a href="../engine/parser/tokenizer.cs.html#2768"><b>2768</b>return NewStringLiteralToken(GetStringAndRelease(sb), <i>TokenKind</i>.HereStringLiteral, flags);</a>
<a href="../engine/parser/tokenizer.cs.html#2779"><b>2779</b>return NewStringExpandableToken(string.Empty, string.Empty, <i>TokenKind</i>.HereStringExpandable, null, TokenFlags.TokenInError);</a>
<a href="../engine/parser/tokenizer.cs.html#2880"><b>2880</b>return NewStringExpandableToken(GetStringAndRelease(sb), GetStringAndRelease(formatSb), <i>TokenKind</i>.HereStringExpandable, nestedTokens, flags);</a>
<a href="../engine/parser/tokenizer.cs.html#3341"><b>3341</b><i>TokenKind</i> operatorKind;</a>
<a href="../engine/parser/tokenizer.cs.html#3350"><b>3350</b>return NewToken(<i>TokenKind</i>.Minus);</a>
<a href="../engine/parser/tokenizer.cs.html#3356"><b>3356</b>private Token CheckOperatorInCommandMode(char c, <i>TokenKind</i> tokenKind)</a>
<a href="../engine/parser/tokenizer.cs.html#3366"><b>3366</b>private Token CheckOperatorInCommandMode(char c1, char c2, <i>TokenKind</i> tokenKind)</a>
<a href="../engine/parser/tokenizer.cs.html#3491"><b>3491</b>return NewToken(<i>TokenKind</i>.DynamicKeyword);</a>
<a href="../engine/parser/tokenizer.cs.html#4219"><b>4219</b>return NewToken(<i>TokenKind</i>.Dot);</a>
<a href="../engine/parser/tokenizer.cs.html#4242"><b>4242</b>return NewToken(<i>TokenKind</i>.ColonColon);</a>
<a href="../engine/parser/tokenizer.cs.html#4253"><b>4253</b>return NewToken(<i>TokenKind</i>.LBracket);</a>
<a href="../engine/parser/tokenizer.cs.html#4264"><b>4264</b>return NewToken(<i>TokenKind</i>.QuestionDot);</a>
<a href="../engine/parser/tokenizer.cs.html#4269"><b>4269</b>return NewToken(<i>TokenKind</i>.QuestionLBracket);</a>
<a href="../engine/parser/tokenizer.cs.html#4287"><b>4287</b>return NewToken(<i>TokenKind</i>.LParen);</a>
<a href="../engine/parser/tokenizer.cs.html#4294"><b>4294</b>return NewToken(<i>TokenKind</i>.LCurly);</a>
<a href="../engine/parser/tokenizer.cs.html#4347"><b>4347</b>return NewToken(<i>TokenKind</i>.LBracket);</a>
<a href="../engine/parser/tokenizer.cs.html#4395"><b>4395</b>return NewToken(<i>TokenKind</i>.DotDot);</a>
<a href="../engine/parser/tokenizer.cs.html#4412"><b>4412</b>return NewToken(<i>TokenKind</i>.Dot);</a>
<a href="../engine/parser/tokenizer.cs.html#4455"><b>4455</b><i>TokenKind</i> tokenKind;</a>
<a href="../engine/parser/tokenizer.cs.html#4460"><b>4460</b>if (tokenKind != <i>TokenKind</i>.InlineScript || InWorkflowContext)</a>
<a href="../engine/parser/tokenizer.cs.html#4466"><b>4466</b>return NewToken(<i>TokenKind</i>.DynamicKeyword);</a>
<a href="../engine/parser/tokenizer.cs.html#4472"><b>4472</b>return NewToken(<i>TokenKind</i>.Identifier);</a>
<a href="../engine/parser/tokenizer.cs.html#4505"><b>4505</b>var result = NewToken(<i>TokenKind</i>.Identifier);</a>
<a href="../engine/parser/tokenizer.cs.html#4529"><b>4529</b>var token = NewToken(<i>TokenKind</i>.Identifier);</a>
<a href="../engine/parser/tokenizer.cs.html#4570"><b>4570</b>NewToken(<i>TokenKind</i>.Comma);</a>
<a href="../engine/parser/tokenizer.cs.html#4578"><b>4578</b>NewToken(<i>TokenKind</i>.Equals);</a>
<a href="../engine/parser/tokenizer.cs.html#4663"><b>4663</b>return NewToken(<i>TokenKind</i>.AtCurly);</a>
<a href="../engine/parser/tokenizer.cs.html#4668"><b>4668</b>return NewToken(<i>TokenKind</i>.AtParen);</a>
<a href="../engine/parser/tokenizer.cs.html#4690"><b>4690</b>return NewToken(<i>TokenKind</i>.Unknown);</a>
<a href="../engine/parser/tokenizer.cs.html#4697"><b>4697</b>return NewToken(<i>TokenKind</i>.NewLine);</a>
<a href="../engine/parser/tokenizer.cs.html#4712"><b>4712</b>NewToken(<i>TokenKind</i>.LineContinuation);</a>
<a href="../engine/parser/tokenizer.cs.html#4737"><b>4737</b>return CheckOperatorInCommandMode(c, <i>TokenKind</i>.Equals);</a>
<a href="../engine/parser/tokenizer.cs.html#4744"><b>4744</b>return CheckOperatorInCommandMode(c, c1, <i>TokenKind</i>.PlusPlus);</a>
<a href="../engine/parser/tokenizer.cs.html#4750"><b>4750</b>return CheckOperatorInCommandMode(c, c1, <i>TokenKind</i>.PlusEquals);</a>
<a href="../engine/parser/tokenizer.cs.html#4758"><b>4758</b>return CheckOperatorInCommandMode(c, <i>TokenKind</i>.Plus);</a>
<a href="../engine/parser/tokenizer.cs.html#4768"><b>4768</b>return CheckOperatorInCommandMode(c, c1, <i>TokenKind</i>.MinusMinus);</a>
<a href="../engine/parser/tokenizer.cs.html#4774"><b>4774</b>return CheckOperatorInCommandMode(c, c1, <i>TokenKind</i>.MinusEquals);</a>
<a href="../engine/parser/tokenizer.cs.html#4787"><b>4787</b>return CheckOperatorInCommandMode(c, <i>TokenKind</i>.Minus);</a>
<a href="../engine/parser/tokenizer.cs.html#4794"><b>4794</b>return CheckOperatorInCommandMode(c, c1, <i>TokenKind</i>.MultiplyEquals);</a>
<a href="../engine/parser/tokenizer.cs.html#4823"><b>4823</b>return CheckOperatorInCommandMode(c, <i>TokenKind</i>.Multiply);</a>
<a href="../engine/parser/tokenizer.cs.html#4830"><b>4830</b>return CheckOperatorInCommandMode(c, c1, <i>TokenKind</i>.DivideEquals);</a>
<a href="../engine/parser/tokenizer.cs.html#4833"><b>4833</b>return CheckOperatorInCommandMode(c, <i>TokenKind</i>.Divide);</a>
<a href="../engine/parser/tokenizer.cs.html#4840"><b>4840</b>return CheckOperatorInCommandMode(c, c1, <i>TokenKind</i>.RemainderEquals);</a>
<a href="../engine/parser/tokenizer.cs.html#4843"><b>4843</b>return CheckOperatorInCommandMode(c, <i>TokenKind</i>.Rem);</a>
<a href="../engine/parser/tokenizer.cs.html#4849"><b>4849</b>return NewToken(<i>TokenKind</i>.DollarParen);</a>
<a href="../engine/parser/tokenizer.cs.html#4929"><b>4929</b>return NewToken(<i>TokenKind</i>.LParen);</a>
<a href="../engine/parser/tokenizer.cs.html#4931"><b>4931</b>return NewToken(<i>TokenKind</i>.RParen);</a>
<a href="../engine/parser/tokenizer.cs.html#4938"><b>4938</b>return NewToken(<i>TokenKind</i>.LBracket);</a>
<a href="../engine/parser/tokenizer.cs.html#4940"><b>4940</b>return NewToken(<i>TokenKind</i>.RBracket);</a>
<a href="../engine/parser/tokenizer.cs.html#4942"><b>4942</b>return NewToken(<i>TokenKind</i>.LCurly);</a>
<a href="../engine/parser/tokenizer.cs.html#4944"><b>4944</b>return NewToken(<i>TokenKind</i>.RCurly);</a>
<a href="../engine/parser/tokenizer.cs.html#4948"><b>4948</b>return NewToken(<i>TokenKind</i>.Semi);</a>
<a href="../engine/parser/tokenizer.cs.html#4950"><b>4950</b>return NewToken(<i>TokenKind</i>.Comma);</a>
<a href="../engine/parser/tokenizer.cs.html#4996"><b>4996</b>return NewToken(<i>TokenKind</i>.AndAnd);</a>
<a href="../engine/parser/tokenizer.cs.html#4999"><b>4999</b>return NewToken(<i>TokenKind</i>.Ampersand);</a>
<a href="../engine/parser/tokenizer.cs.html#5005"><b>5005</b>return NewToken(<i>TokenKind</i>.OrOr);</a>
<a href="../engine/parser/tokenizer.cs.html#5008"><b>5008</b>return NewToken(<i>TokenKind</i>.Pipe);</a>
<a href="../engine/parser/tokenizer.cs.html#5032"><b>5032</b>return NewToken(<i>TokenKind</i>.Exclaim);</a>
<a href="../engine/parser/tokenizer.cs.html#5045"><b>5045</b>return NewToken(<i>TokenKind</i>.ColonColon);</a>
<a href="../engine/parser/tokenizer.cs.html#5053"><b>5053</b>return this.NewToken(<i>TokenKind</i>.Colon);</a>
<a href="../engine/parser/tokenizer.cs.html#5066"><b>5066</b>return this.NewToken(<i>TokenKind</i>.QuestionQuestionEquals);</a>
<a href="../engine/parser/tokenizer.cs.html#5069"><b>5069</b>return this.NewToken(<i>TokenKind</i>.QuestionQuestion);</a>
<a href="../engine/parser/tokenizer.cs.html#5072"><b>5072</b>return this.NewToken(<i>TokenKind</i>.QuestionMark);</a>
<a href="../engine/parser/tokenizer.cs.html#5077"><b>5077</b>return SaveToken(new Token(NewScriptExtent(_tokenStart + 1, _tokenStart + 1), <i>TokenKind</i>.EndOfInput, TokenFlags.None));</a>
</div>
<div class="rF"><div class="rN">engine\parser\TypeInferenceVisitor.cs (3)</div>
<a href="../engine/parser/TypeInferenceVisitor.cs.html#646"><b>646</b><i>var</i> tokenKind = unaryExpressionAst.TokenKind;</a>
<a href="../engine/parser/TypeInferenceVisitor.cs.html#647"><b>647</b>return (tokenKind == <i>TokenKind</i>.Not || tokenKind == <i>TokenKind</i>.Exclaim)</a>
</div>
<div class="rF"><div class="rN">engine\parser\VariableAnalysis.cs (3)</div>
<a href="../engine/parser/VariableAnalysis.cs.html#289"><b>289</b>if (commandAst.InvocationOperator == <i>TokenKind</i>.Dot)</a>
<a href="../engine/parser/VariableAnalysis.cs.html#1666"><b>1666</b>if (binaryExpressionAst.Operator == <i>TokenKind</i>.And || binaryExpressionAst.Operator == <i>TokenKind</i>.Or)</a>
</div>
<div class="rF"><div class="rN">engine\runtime\Binding\Binders.cs (24)</div>
<a href="../engine/runtime/Binding/Binders.cs.html#2263"><b>2263</b>case ExpressionType.Add: return <i>TokenKind</i>.Plus.Text();</a>
<a href="../engine/runtime/Binding/Binders.cs.html#2264"><b>2264</b>case ExpressionType.Subtract: return <i>TokenKind</i>.Minus.Text();</a>
<a href="../engine/runtime/Binding/Binders.cs.html#2265"><b>2265</b>case ExpressionType.Multiply: return <i>TokenKind</i>.Multiply.Text();</a>
<a href="../engine/runtime/Binding/Binders.cs.html#2266"><b>2266</b>case ExpressionType.Divide: return <i>TokenKind</i>.Divide.Text();</a>
<a href="../engine/runtime/Binding/Binders.cs.html#2267"><b>2267</b>case ExpressionType.Modulo: return <i>TokenKind</i>.Rem.Text();</a>
<a href="../engine/runtime/Binding/Binders.cs.html#2268"><b>2268</b>case ExpressionType.And: return <i>TokenKind</i>.Band.Text();</a>
<a href="../engine/runtime/Binding/Binders.cs.html#2269"><b>2269</b>case ExpressionType.Or: return <i>TokenKind</i>.Bor.Text();</a>
<a href="../engine/runtime/Binding/Binders.cs.html#2270"><b>2270</b>case ExpressionType.ExclusiveOr: return <i>TokenKind</i>.Bxor.Text();</a>
<a href="../engine/runtime/Binding/Binders.cs.html#2271"><b>2271</b>case ExpressionType.Equal: return _ignoreCase ? <i>TokenKind</i>.Ieq.Text() : <i>TokenKind</i>.Ceq.Text();</a>
<a href="../engine/runtime/Binding/Binders.cs.html#2272"><b>2272</b>case ExpressionType.NotEqual: return _ignoreCase ? <i>TokenKind</i>.Ine.Text() : <i>TokenKind</i>.Cne.Text();</a>
<a href="../engine/runtime/Binding/Binders.cs.html#2273"><b>2273</b>case ExpressionType.GreaterThan: return _ignoreCase ? <i>TokenKind</i>.Igt.Text() : <i>TokenKind</i>.Cgt.Text();</a>
<a href="../engine/runtime/Binding/Binders.cs.html#2274"><b>2274</b>case ExpressionType.GreaterThanOrEqual: return _ignoreCase ? <i>TokenKind</i>.Ige.Text() : <i>TokenKind</i>.Cge.Text();</a>
<a href="../engine/runtime/Binding/Binders.cs.html#2275"><b>2275</b>case ExpressionType.LessThan: return _ignoreCase ? <i>TokenKind</i>.Ilt.Text() : <i>TokenKind</i>.Clt.Text();</a>
<a href="../engine/runtime/Binding/Binders.cs.html#2276"><b>2276</b>case ExpressionType.LessThanOrEqual: return _ignoreCase ? <i>TokenKind</i>.Ile.Text() : <i>TokenKind</i>.Cle.Text();</a>
<a href="../engine/runtime/Binding/Binders.cs.html#2277"><b>2277</b>case ExpressionType.LeftShift: return <i>TokenKind</i>.Shl.Text();</a>
<a href="../engine/runtime/Binding/Binders.cs.html#2278"><b>2278</b>case ExpressionType.RightShift: return <i>TokenKind</i>.Shr.Text();</a>
<a href="../engine/runtime/Binding/Binders.cs.html#3722"><b>3722</b>Expression.Constant((Operation == ExpressionType.Increment ? <i>TokenKind</i>.PlusPlus : <i>TokenKind</i>.MinusMinus).Text()),</a>
</div>
<div class="rF"><div class="rN">engine\runtime\Operations\MiscOps.cs (6)</div>
<a href="../engine/runtime/Operations/MiscOps.cs.html#36"><b>36</b><i>var</i> invocationToken = commandAst != null ? commandAst.InvocationOperator : <i>TokenKind</i>.Unknown;</a>
<a href="../engine/runtime/Operations/MiscOps.cs.html#37"><b>37</b>bool dotSource = invocationToken == <i>TokenKind</i>.Dot;</a>
<a href="../engine/runtime/Operations/MiscOps.cs.html#56"><b>56</b>else if (((invocationToken == <i>TokenKind</i>.Ampersand) || (invocationToken == <i>TokenKind</i>.Dot)) &amp;&amp; (mi.LanguageMode != context.LanguageMode))</a>
<a href="../engine/runtime/Operations/MiscOps.cs.html#90"><b>90</b>string invocationName = (dotSource) ? &quot;.&quot; : invocationToken == <i>TokenKind</i>.Ampersand ? &quot;&amp;&quot; : null;</a>
</div>
<div class="rF"><div class="rN">engine\runtime\ScriptBlockToPowerShell.cs (1)</div>
<a href="../engine/runtime/ScriptBlockToPowerShell.cs.html#67"><b>67</b>if (commandAst.InvocationOperator == <i>TokenKind</i>.Dot)</a>
</div>
<div class="rF"><div class="rN">help\HelpCommentsParser.cs (9)</div>
<a href="../help/HelpCommentsParser.cs.html#968"><b>968</b>if (current.Kind == <i>TokenKind</i>.Comment)</a>
<a href="../help/HelpCommentsParser.cs.html#976"><b>976</b>else if (current.Kind != <i>TokenKind</i>.NewLine)</a>
<a href="../help/HelpCommentsParser.cs.html#999"><b>999</b>if (current.Kind == <i>TokenKind</i>.Comment)</a>
<a href="../help/HelpCommentsParser.cs.html#1004"><b>1004</b>else if (current.Kind != <i>TokenKind</i>.NewLine)</a>
<a href="../help/HelpCommentsParser.cs.html#1070"><b>1070</b>if (tokens[i].Kind == <i>TokenKind</i>.Comment)</a>
<a href="../help/HelpCommentsParser.cs.html#1149"><b>1149</b>Diagnostics.Assert(tokens[startTokenIndex - 1].Kind == <i>TokenKind</i>.LCurly,</a>
<a href="../help/HelpCommentsParser.cs.html#1151"><b>1151</b>Diagnostics.Assert(tokens[lastTokenIndex].Kind == <i>TokenKind</i>.RCurly,</a>
<a href="../help/HelpCommentsParser.cs.html#1174"><b>1174</b>Diagnostics.Assert(tokens[startTokenIndex - 1].Kind == <i>TokenKind</i>.LCurly,</a>
<a href="../help/HelpCommentsParser.cs.html#1176"><b>1176</b>Diagnostics.Assert(tokens[lastTokenIndex].Kind == <i>TokenKind</i>.RCurly,</a>
</div>
</div>
</body></html>