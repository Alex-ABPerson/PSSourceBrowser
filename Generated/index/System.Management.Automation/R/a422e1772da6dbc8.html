<!DOCTYPE html>
<html><head><title>ITypeName</title><link rel="stylesheet" href="../../styles.css"/><script src="../../scripts.js"></script></head><body onload="ro();">
<div class="rH">4 implementations of ITypeName</div><div class="rA">System.Management.Automation (4)</div><div class="rG" id="System.Management.Automation"><div class="rF"><div class="rN">engine\parser\ast.cs (4)</div>
<a href="../engine/parser/ast.cs.html#8198"><b>8198</b>public sealed class TypeName : <i>ITypeName</i>, ISupportsTypeCaching</a>
<a href="../engine/parser/ast.cs.html#8464"><b>8464</b>public sealed class GenericTypeName : <i>ITypeName</i>, ISupportsTypeCaching</a>
<a href="../engine/parser/ast.cs.html#8765"><b>8765</b>public sealed class ArrayTypeName : <i>ITypeName</i>, ISupportsTypeCaching</a>
<a href="../engine/parser/ast.cs.html#8970"><b>8970</b>public sealed class ReflectionTypeName : <i>ITypeName</i>, ISupportsTypeCaching</a>
</div>
</div>
<div class="rH">53 references to ITypeName</div><div class="rA">System.Management.Automation (53)</div><div class="rG" id="System.Management.Automation"><div class="rF"><div class="rN">DscSupport\CimDSCParser.cs (1)</div>
<a href="../DscSupport/CimDSCParser.cs.html#2317"><b>2317</b>internal static string MapTypeNameToMofType(<i>ITypeName</i> typeName, string memberName, string className, out bool isArrayType, out string embeddedInstanceType, List&lt;object&gt; embeddedInstanceTypes, ref string[] enumNames)</a>
</div>
<div class="rF"><div class="rN">engine\CommandCompletion\CompletionAnalysis.cs (1)</div>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#1016"><b>1016</b>internal static TypeName FindTypeNameToComplete(<i>ITypeName</i> type, IScriptPosition cursor)</a>
</div>
<div class="rF"><div class="rN">engine\CommandCompletion\CompletionCompleters.cs (1)</div>
<a href="../engine/CommandCompletion/CompletionCompleters.cs.html#3894"><b>3894</b><i>var</i> fullTypeName = Parser.ScanType(wordToComplete, ignoreErrors: true);</a>
</div>
<div class="rF"><div class="rN">engine\CommandInfo.cs (1)</div>
<a href="../engine/CommandInfo.cs.html#816"><b>816</b>public PSTypeName(<i>ITypeName</i> typeName)</a>
</div>
<div class="rF"><div class="rN">engine\parser\ast.cs (15)</div>
<a href="../engine/parser/ast.cs.html#2005"><b>2005</b>protected AttributeBaseAst(IScriptExtent extent, <i>ITypeName</i> typeName)</a>
<a href="../engine/parser/ast.cs.html#2019"><b>2019</b>public <i>ITypeName</i> TypeName { get; }</a>
<a href="../engine/parser/ast.cs.html#2046"><b>2046</b><i>ITypeName</i> typeName,</a>
<a href="../engine/parser/ast.cs.html#2148"><b>2148</b>public TypeConstraintAst(IScriptExtent extent, <i>ITypeName</i> typeName)</a>
<a href="../engine/parser/ast.cs.html#8486"><b>8486</b>public GenericTypeName(IScriptExtent extent, <i>ITypeName</i> genericTypeName, IEnumerable&lt;<i>ITypeName</i>&gt; genericArguments)</a>
<a href="../engine/parser/ast.cs.html#8500"><b>8500</b>this.GenericArguments = new ReadOnlyCollection&lt;<i>ITypeName</i>&gt;(genericArguments.ToArray());</a>
<a href="../engine/parser/ast.cs.html#8523"><b>8523</b><i>ITypeName</i> typename = GenericArguments[index];</a>
<a href="../engine/parser/ast.cs.html#8561"><b>8561</b><i>ITypeName</i> typename = GenericArguments[index];</a>
<a href="../engine/parser/ast.cs.html#8594"><b>8594</b>public <i>ITypeName</i> TypeName { get; }</a>
<a href="../engine/parser/ast.cs.html#8599"><b>8599</b>public ReadOnlyCollection&lt;<i>ITypeName</i>&gt; GenericArguments { get; }</a>
<a href="../engine/parser/ast.cs.html#8782"><b>8782</b>public ArrayTypeName(IScriptExtent extent, <i>ITypeName</i> elementType, int rank)</a>
<a href="../engine/parser/ast.cs.html#8874"><b>8874</b>public <i>ITypeName</i> ElementType { get; }</a>
<a href="../engine/parser/ast.cs.html#9080"><b>9080</b>public TypeExpressionAst(IScriptExtent extent, <i>ITypeName</i> typeName)</a>
<a href="../engine/parser/ast.cs.html#9094"><b>9094</b>public <i>ITypeName</i> TypeName { get; }</a>
</div>
<div class="rF"><div class="rN">engine\parser\Compiler.cs (3)</div>
<a href="../engine/parser/Compiler.cs.html#1197"><b>1197</b><i>var</i> typeName = typeConstraint.TypeName;</a>
<a href="../engine/parser/Compiler.cs.html#6084"><b>6084</b><i>var</i> typeName = convertExpressionAst.Type.TypeName;</a>
<a href="../engine/parser/Compiler.cs.html#6231"><b>6231</b>internal Expression CompileTypeName(<i>ITypeName</i> typeName, IScriptExtent errorPos)</a>
</div>
<div class="rF"><div class="rN">engine\parser\Parser.cs (16)</div>
<a href="../engine/parser/Parser.cs.html#272"><b>272</b>internal static <i>ITypeName</i> ScanType(string typename, bool ignoreErrors)</a>
<a href="../engine/parser/Parser.cs.html#284"><b>284</b><i>var</i> result = parser.TypeNameRule(allowAssemblyQualifiedNames: true, firstTypeNameToken: out unused);</a>
<a href="../engine/parser/Parser.cs.html#637"><b>637</b><i>var</i> typename = obj as <i>ITypeName</i>;</a>
<a href="../engine/parser/Parser.cs.html#1076"><b>1076</b><i>ITypeName</i> typeName = TypeNameRule(allowAssemblyQualifiedNames: true, firstTypeNameToken: out firstTypeNameToken);</a>
<a href="../engine/parser/Parser.cs.html#1277"><b>1277</b>private <i>ITypeName</i> TypeNameRule(bool allowAssemblyQualifiedNames, out Token firstTypeNameToken)</a>
<a href="../engine/parser/Parser.cs.html#1339"><b>1339</b>private <i>ITypeName</i> FinishTypeNameRule(Token typeName, bool unBracketedGenericArg = false, bool allowAssemblyQualifiedNames = true)</a>
<a href="../engine/parser/Parser.cs.html#1403"><b>1403</b>private <i>ITypeName</i> GetSingleGenericArgument(Token firstToken)</a>
<a href="../engine/parser/Parser.cs.html#1422"><b>1422</b><i>ITypeName</i> typeName = FinishTypeNameRule(token);</a>
<a href="../engine/parser/Parser.cs.html#1440"><b>1440</b>private <i>ITypeName</i> GenericTypeArgumentsRule(Token genericTypeName, Token firstToken, bool unBracketedGenericArg)</a>
<a href="../engine/parser/Parser.cs.html#1444"><b>1444</b>var genericArguments = new List&lt;<i>ITypeName</i>&gt;();</a>
<a href="../engine/parser/Parser.cs.html#1446"><b>1446</b><i>ITypeName</i> typeName = GetSingleGenericArgument(firstToken);</a>
<a href="../engine/parser/Parser.cs.html#1519"><b>1519</b>private <i>ITypeName</i> CompleteArrayTypeName(<i>ITypeName</i> elementType, TypeName typeForAssemblyQualification, Token firstTokenAfterLBracket)</a>
<a href="../engine/parser/Parser.cs.html#4225"><b>4225</b><i>ITypeName</i> superClass;</a>
<a href="../engine/parser/Parser.cs.html#4710"><b>4710</b><i>ITypeName</i> underlyingType;</a>
</div>
<div class="rF"><div class="rN">engine\parser\SemanticChecks.cs (3)</div>
<a href="../engine/parser/SemanticChecks.cs.html#350"><b>350</b>internal static void CheckArrayTypeNameDepth(<i>ITypeName</i> typeName, IScriptExtent extent, Parser parser)</a>
<a href="../engine/parser/SemanticChecks.cs.html#353"><b>353</b><i>ITypeName</i> type = typeName;</a>
<a href="../engine/parser/SemanticChecks.cs.html#1874"><b>1874</b>private void CheckTypeName(Ast ast, <i>ITypeName</i> typename)</a>
</div>
<div class="rF"><div class="rN">engine\parser\SymbolResolver.cs (1)</div>
<a href="../engine/parser/SymbolResolver.cs.html#598"><b>598</b>private bool DispatchTypeName(<i>ITypeName</i> type, int genericArgumentCount, bool isAttribute)</a>
</div>
<div class="rF"><div class="rN">engine\parser\TypeResolver.cs (10)</div>
<a href="../engine/parser/TypeResolver.cs.html#462"><b>462</b>internal static Type ResolveITypeName(<i>ITypeName</i> iTypeName, out Exception exception)</a>
<a href="../engine/parser/TypeResolver.cs.html#497"><b>497</b><i>var</i> iTypeName = Parser.ScanType(strTypeName, ignoreErrors: false);</a>
<a href="../engine/parser/TypeResolver.cs.html#676"><b>676</b>private sealed class KeyComparer : IEqualityComparer&lt;Tuple&lt;<i>ITypeName</i>, TypeResolutionState&gt;&gt;</a>
<a href="../engine/parser/TypeResolver.cs.html#678"><b>678</b>public bool Equals(Tuple&lt;<i>ITypeName</i>, TypeResolutionState&gt; x,</a>
<a href="../engine/parser/TypeResolver.cs.html#679"><b>679</b>Tuple&lt;<i>ITypeName</i>, TypeResolutionState&gt; y)</a>
<a href="../engine/parser/TypeResolver.cs.html#684"><b>684</b>public int GetHashCode(Tuple&lt;<i>ITypeName</i>, TypeResolutionState&gt; obj)</a>
<a href="../engine/parser/TypeResolver.cs.html#690"><b>690</b>private static readonly ConcurrentDictionary&lt;Tuple&lt;<i>ITypeName</i>, TypeResolutionState&gt;, Type&gt; s_cache = new ConcurrentDictionary&lt;Tuple&lt;<i>ITypeName</i>, TypeResolutionState&gt;, Type&gt;(new KeyComparer());</a>
<a href="../engine/parser/TypeResolver.cs.html#692"><b>692</b>internal static Type Lookup(<i>ITypeName</i> typeName, TypeResolutionState typeResolutionState)</a>
<a href="../engine/parser/TypeResolver.cs.html#699"><b>699</b>internal static void Add(<i>ITypeName</i> typeName, TypeResolutionState typeResolutionState, Type type)</a>
</div>
<div class="rF"><div class="rN">engine\runtime\Operations\MiscOps.cs (1)</div>
<a href="../engine/runtime/Operations/MiscOps.cs.html#2106"><b>2106</b>internal static Type ResolveTypeName(<i>ITypeName</i> typeName, IScriptExtent errorPos)</a>
</div>
</div>
</body></html>