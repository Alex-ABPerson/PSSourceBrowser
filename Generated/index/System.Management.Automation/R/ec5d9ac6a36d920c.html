<!DOCTYPE html>
<html><head><title>Token</title><link rel="stylesheet" href="../../styles.css"/><script src="../../scripts.js"></script></head><body onload="ro();">
<div class="rH">6 types derived from Token</div><div class="rA">System.Management.Automation (6)</div><div class="rG" id="System.Management.Automation"><div class="rF"><div class="rN">engine\parser\token.cs (6)</div>
<a href="../engine/parser/token.cs.html#1274"><b>1274</b>public class NumberToken : <i>Token</i></a>
<a href="../engine/parser/token.cs.html#1299"><b>1299</b>public class ParameterToken : <i>Token</i></a>
<a href="../engine/parser/token.cs.html#1336"><b>1336</b>public class VariableToken : <i>Token</i></a>
<a href="../engine/parser/token.cs.html#1364"><b>1364</b>public abstract class StringToken : <i>Token</i></a>
<a href="../engine/parser/token.cs.html#1456"><b>1456</b>public class LabelToken : <i>Token</i></a>
<a href="../engine/parser/token.cs.html#1472"><b>1472</b>public abstract class RedirectionToken : <i>Token</i></a>
</div>
</div>
<div class="rH">4 instantiations of Token</div><div class="rA">System.Management.Automation (4)</div><div class="rG" id="System.Management.Automation"><div class="rF"><div class="rN">engine\parser\Parser.cs (1)</div>
<a href="../engine/parser/Parser.cs.html#1144"><b>1144</b>var typeToken = new <i>Token</i>((InternalScriptExtent)ExtentOf(lBracket, lParenOrRBracket),</a>
</div>
<div class="rF"><div class="rN">engine\parser\tokenizer.cs (3)</div>
<a href="../engine/parser/tokenizer.cs.html#1216"><b>1216</b>return SaveToken(new <i>Token</i>(CurrentExtent(), TokenKind.Comment, TokenFlags.None));</a>
<a href="../engine/parser/tokenizer.cs.html#1251"><b>1251</b>return SaveToken(new <i>Token</i>(CurrentExtent(), kind, TokenFlags.None));</a>
<a href="../engine/parser/tokenizer.cs.html#5077"><b>5077</b>return SaveToken(new <i>Token</i>(NewScriptExtent(_tokenStart + 1, _tokenStart + 1), TokenKind.EndOfInput, TokenFlags.None));</a>
</div>
</div>
<div class="rH">417 references to Token</div><div class="rA">Microsoft.PowerShell.Commands.Utility (1)</div><div class="rG" id="Microsoft.PowerShell.Commands.Utility"><div class="rF"><div class="rN">commands\utility\ImportPowerShellDataFile.cs (1)</div>
<a href="../../Microsoft.PowerShell.Commands.Utility/commands/utility/ImportPowerShellDataFile.cs.html#58"><b>58</b><i>Token</i>[] tokens;</a>
</div>
</div>
<div class="rA">Microsoft.PowerShell.ConsoleHost (2)</div><div class="rG" id="Microsoft.PowerShell.ConsoleHost"><div class="rF"><div class="rN">host\msh\ConsoleHost.cs (2)</div>
<a href="../../Microsoft.PowerShell.ConsoleHost/host/msh/ConsoleHost.cs.html#1905"><b>1905</b><i>Token</i>[] tokens;</a>
<a href="../../Microsoft.PowerShell.ConsoleHost/host/msh/ConsoleHost.cs.html#1967"><b>1967</b><i>Token</i>[] tokens;</a>
</div>
</div>
<div class="rA">System.Management.Automation (414)</div><div class="rG" id="System.Management.Automation"><div class="rF"><div class="rN">DscSupport\CimDSCParser.cs (2)</div>
<a href="../DscSupport/CimDSCParser.cs.html#2599"><b>2599</b><i>Token</i>[] tokens;</a>
<a href="../DscSupport/CimDSCParser.cs.html#3370"><b>3370</b><i>Token</i>[] tokens; ParseError[] errors;</a>
</div>
<div class="rF"><div class="rN">engine\CommandCompletion\CommandCompletion.cs (8)</div>
<a href="../engine/CommandCompletion/CommandCompletion.cs.html#72"><b>72</b>public static Tuple&lt;Ast, <i>Token</i>[], IScriptPosition&gt; MapStringInputToParsedInput(string input, int cursorIndex)</a>
<a href="../engine/CommandCompletion/CommandCompletion.cs.html#79"><b>79</b><i>Token</i>[] tokens;</a>
<a href="../engine/CommandCompletion/CommandCompletion.cs.html#85"><b>85</b>return Tuple.Create&lt;Ast, <i>Token</i>[], IScriptPosition&gt;(ast, tokens, cursorPosition);</a>
<a href="../engine/CommandCompletion/CommandCompletion.cs.html#112"><b>112</b>public static CommandCompletion CompleteInput(Ast ast, <i>Token</i>[] tokens, IScriptPosition positionOfCursor, Hashtable options)</a>
<a href="../engine/CommandCompletion/CommandCompletion.cs.html#216"><b>216</b>public static CommandCompletion CompleteInput(Ast ast, <i>Token</i>[] tokens, IScriptPosition cursorPosition, Hashtable options, PowerShell powershell)</a>
<a href="../engine/CommandCompletion/CommandCompletion.cs.html#363"><b>363</b>internal static CommandCompletion CompleteInputInDebugger(Ast ast, <i>Token</i>[] tokens, IScriptPosition cursorPosition, Hashtable options, Debugger debugger)</a>
<a href="../engine/CommandCompletion/CommandCompletion.cs.html#479"><b>479</b>private static CommandCompletion CallScriptWithAstParameterSet(Ast ast, <i>Token</i>[] tokens, IScriptPosition cursorPosition, Hashtable options, PowerShell powershell)</a>
<a href="../engine/CommandCompletion/CommandCompletion.cs.html#517"><b>517</b>private static CommandCompletion CompleteInputImpl(Ast ast, <i>Token</i>[] tokens, IScriptPosition positionOfCursor, Hashtable options)</a>
</div>
<div class="rF"><div class="rN">engine\CommandCompletion\CompletionAnalysis.cs (29)</div>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#24"><b>24</b>internal <i>Token</i> TokenAtCursor { get; set; }</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#26"><b>26</b>internal <i>Token</i> TokenBeforeCursor { get; set; }</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#64"><b>64</b>private readonly <i>Token</i>[] _tokens;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#68"><b>68</b>internal CompletionAnalysis(Ast ast, <i>Token</i>[] tokens, IScriptPosition cursorPosition, Hashtable options)</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#76"><b>76</b>private static bool IsInterestingToken(<i>Token</i> token)</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#113"><b>113</b>internal AstAnalysisContext(<i>Token</i> tokenAtCursor, <i>Token</i> tokenBeforeCursor, List&lt;Ast&gt; relatedAsts, int replacementIndex)</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#121"><b>121</b>internal readonly <i>Token</i> TokenAtCursor;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#122"><b>122</b>internal readonly <i>Token</i> TokenBeforeCursor;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#127"><b>127</b>internal static AstAnalysisContext ExtractAstContext(Ast inputAst, <i>Token</i>[] inputTokens, IScriptPosition cursor)</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#132"><b>132</b><i>Token</i> tokenBeforeCursor = null;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#133"><b>133</b><i>Token</i> tokenAtCursor = InterstingTokenAtCursorOrDefault(inputTokens, cursor);</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#201"><b>201</b>private static <i>Token</i> InterstingTokenAtCursorOrDefault(IReadOnlyList&lt;<i>Token</i>&gt; tokens, IScriptPosition cursorPosition)</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#205"><b>205</b><i>Token</i> token = tokens[i];</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#215"><b>215</b>private static <i>Token</i> InterstingTokenBeforeCursorOrDefault(IReadOnlyList&lt;<i>Token</i>&gt; tokens, IScriptPosition cursorPosition)</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#219"><b>219</b><i>Token</i> token = tokens[i];</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#240"><b>240</b>private static bool CompleteAgainstSwitchFile(Ast lastAst, <i>Token</i> tokenBeforeCursor)</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#242"><b>242</b>Tuple&lt;<i>Token</i>, Ast&gt; fileConditionTuple;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#273"><b>273</b>private static bool CompleteOperator(<i>Token</i> tokenAtCursor, Ast lastAst)</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#288"><b>288</b>private static bool CompleteAgainstStatementFlags(Ast scriptAst, Ast lastAst, <i>Token</i> token, out TokenKind kind)</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#329"><b>329</b>Tuple&lt;<i>Token</i>, Ast&gt; value;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#350"><b>350</b>private static bool IsTokenTheSame(<i>Token</i> x, <i>Token</i> y)</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#396"><b>396</b><i>var</i> tokenAtCursor = completionContext.TokenAtCursor;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#712"><b>712</b><i>var</i> tokenBeforeCursor = completionContext.TokenBeforeCursor;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#1533"><b>1533</b><i>var</i> tokenAtCursor = completionContext.TokenAtCursor;</a>
<a href="../engine/CommandCompletion/CompletionAnalysis.cs.html#1755"><b>1755</b><i>var</i> tokenAtCursor = completionContext.TokenAtCursor;</a>
</div>
<div class="rF"><div class="rN">engine\CommandCompletion\CompletionCompleters.cs (3)</div>
<a href="../engine/CommandCompletion/CompletionCompleters.cs.html#1088"><b>1088</b><i>var</i> token = context.TokenAtCursor ?? context.TokenBeforeCursor;</a>
<a href="../engine/CommandCompletion/CompletionCompleters.cs.html#3980"><b>3980</b>private static ArgumentLocation FindTargetArgumentLocation(Collection&lt;AstParameterArgumentPair&gt; parsedArguments, <i>Token</i> token)</a>
<a href="../engine/CommandCompletion/CompletionCompleters.cs.html#7250"><b>7250</b>Language.<i>Token</i>[] tokens;</a>
</div>
<div class="rF"><div class="rN">engine\debugger\debugger.cs (1)</div>
<a href="../engine/debugger/debugger.cs.html#4856"><b>4856</b><i>Token</i>[] tokens;</a>
</div>
<div class="rF"><div class="rN">engine\lang\interface\PSParser.cs (2)</div>
<a href="../engine/lang/interface/PSParser.cs.html#79"><b>79</b>private readonly List&lt;Language.<i>Token</i>&gt; _tokenList = new List&lt;Language.<i>Token</i>&gt;();</a>
</div>
<div class="rF"><div class="rN">engine\lang\interface\PSToken.cs (2)</div>
<a href="../engine/lang/interface/PSToken.cs.html#30"><b>30</b>internal PSToken(<i>Token</i> token)</a>
<a href="../engine/lang/interface/PSToken.cs.html#81"><b>81</b>public static PSTokenType GetPSTokenType(<i>Token</i> token)</a>
</div>
<div class="rF"><div class="rN">engine\Modules\ImportModuleCommand.cs (2)</div>
<a href="../engine/Modules/ImportModuleCommand.cs.html#28"><b>28</b>using Token = System.Management.Automation.Language.<i>Token</i>;</a>
<a href="../engine/Modules/ImportModuleCommand.cs.html#1506"><b>1506</b><i>Token</i>[] throwAwayTokens;</a>
</div>
<div class="rF"><div class="rN">engine\Modules\RemoteDiscoveryHelper.cs (1)</div>
<a href="../engine/Modules/RemoteDiscoveryHelper.cs.html#1011"><b>1011</b>System.Management.Automation.Language.<i>Token</i>[] throwAwayTokens;</a>
</div>
<div class="rF"><div class="rN">engine\parser\ast.cs (28)</div>
<a href="../engine/parser/ast.cs.html#469"><b>469</b>internal ErrorStatementAst(IScriptExtent extent, <i>Token</i> kind, IEnumerable&lt;Ast&gt; nestedAsts = null)</a>
<a href="../engine/parser/ast.cs.html#485"><b>485</b>internal ErrorStatementAst(IScriptExtent extent, <i>Token</i> kind, IEnumerable&lt;KeyValuePair&lt;string, Tuple&lt;<i>Token</i>, Ast&gt;&gt;&gt; flags, IEnumerable&lt;Ast&gt; conditions, IEnumerable&lt;Ast&gt; bodies)</a>
<a href="../engine/parser/ast.cs.html#496"><b>496</b>Flags = new Dictionary&lt;string, Tuple&lt;<i>Token</i>, Ast&gt;&gt;(StringComparer.OrdinalIgnoreCase);</a>
<a href="../engine/parser/ast.cs.html#497"><b>497</b>foreach (KeyValuePair&lt;string, Tuple&lt;<i>Token</i>, Ast&gt;&gt; entry in flags)</a>
<a href="../engine/parser/ast.cs.html#527"><b>527</b>public <i>Token</i> Kind { get; }</a>
<a href="../engine/parser/ast.cs.html#537"><b>537</b>public Dictionary&lt;string, Tuple&lt;<i>Token</i>, Ast&gt;&gt; Flags { get; }</a>
<a href="../engine/parser/ast.cs.html#570"><b>570</b>Dictionary&lt;string, Tuple&lt;<i>Token</i>, Ast&gt;&gt; newFlags = null;</a>
<a href="../engine/parser/ast.cs.html#574"><b>574</b>newFlags = new Dictionary&lt;string, Tuple&lt;<i>Token</i>, Ast&gt;&gt;(StringComparer.OrdinalIgnoreCase);</a>
<a href="../engine/parser/ast.cs.html#575"><b>575</b>foreach (KeyValuePair&lt;string, Tuple&lt;<i>Token</i>, Ast&gt;&gt; entry in this.Flags)</a>
<a href="../engine/parser/ast.cs.html#578"><b>578</b>newFlags.Add(entry.Key, new Tuple&lt;<i>Token</i>, Ast&gt;(entry.Value.Item1, newAst));</a>
<a href="../engine/parser/ast.cs.html#1135"><b>1135</b>Dictionary&lt;Ast, <i>Token</i>[]&gt; scriptBlockTokenCache = new Dictionary&lt;Ast, <i>Token</i>[]&gt;();</a>
<a href="../engine/parser/ast.cs.html#3647"><b>3647</b><i>Token</i> functionNameToken,</a>
<a href="../engine/parser/ast.cs.html#3698"><b>3698</b>Dictionary&lt;Ast, <i>Token</i>[]&gt; scriptBlockTokenCache = new Dictionary&lt;Ast, <i>Token</i>[]&gt;();</a>
<a href="../engine/parser/ast.cs.html#3718"><b>3718</b>public CommentHelpInfo GetHelpContent(Dictionary&lt;Ast, <i>Token</i>[]&gt; scriptBlockTokenCache)</a>
<a href="../engine/parser/ast.cs.html#6486"><b>6486</b>internal <i>Token</i> LCurlyToken { get; set; }</a>
<a href="../engine/parser/ast.cs.html#6488"><b>6488</b>internal <i>Token</i> ConfigurationToken { get; set; }</a>
<a href="../engine/parser/ast.cs.html#6771"><b>6771</b><i>Token</i>[] tokens;</a>
<a href="../engine/parser/ast.cs.html#6797"><b>6797</b><i>Token</i>[] tokens;</a>
<a href="../engine/parser/ast.cs.html#6832"><b>6832</b><i>Token</i>[] tokens;</a>
<a href="../engine/parser/ast.cs.html#6970"><b>6970</b>internal <i>Token</i> LCurly { get; set; }</a>
<a href="../engine/parser/ast.cs.html#6972"><b>6972</b>internal <i>Token</i> FunctionName { get; set; }</a>
<a href="../engine/parser/ast.cs.html#7582"><b>7582</b>public BlockStatementAst(IScriptExtent extent, <i>Token</i> kind, StatementBlockAst body)</a>
<a href="../engine/parser/ast.cs.html#7608"><b>7608</b>public <i>Token</i> Kind { get; }</a>
<a href="../engine/parser/ast.cs.html#9511"><b>9511</b>internal static StringConstantType MapTokenKindToStringConstantKind(<i>Token</i> token)</a>
<a href="../engine/parser/ast.cs.html#9614"><b>9614</b>internal ExpandableStringExpressionAst(<i>Token</i> token, string value, string formatString, IEnumerable&lt;ExpressionAst&gt; nestedExpressions)</a>
</div>
<div class="rF"><div class="rN">engine\parser\Parser.cs (232)</div>
<a href="../engine/parser/Parser.cs.html#38"><b>38</b>internal <i>Token</i> _ungotToken;</a>
<a href="../engine/parser/Parser.cs.html#65"><b>65</b>public static ScriptBlockAst ParseFile(string fileName, out <i>Token</i>[] tokens, out ParseError[] errors)</a>
<a href="../engine/parser/Parser.cs.html#90"><b>90</b>tokens = Array.Empty&lt;<i>Token</i>&gt;();</a>
<a href="../engine/parser/Parser.cs.html#94"><b>94</b>var tokenList = new List&lt;<i>Token</i>&gt;();</a>
<a href="../engine/parser/Parser.cs.html#130"><b>130</b>public static ScriptBlockAst ParseInput(string input, out <i>Token</i>[] tokens, out ParseError[] errors)</a>
<a href="../engine/parser/Parser.cs.html#143"><b>143</b>public static ScriptBlockAst ParseInput(string input, string fileName, out <i>Token</i>[] tokens, out ParseError[] errors)</a>
<a href="../engine/parser/Parser.cs.html#151"><b>151</b>List&lt;<i>Token</i>&gt; tokenList = new List&lt;<i>Token</i>&gt;();</a>
<a href="../engine/parser/Parser.cs.html#166"><b>166</b>internal ScriptBlockAst Parse(string fileName, string input, List&lt;<i>Token</i>&gt; tokenList, out ParseError[] errors, ParseMode parseMode)</a>
<a href="../engine/parser/Parser.cs.html#178"><b>178</b>private ScriptBlockAst ParseTask(string fileName, string input, List&lt;<i>Token</i>&gt; tokenList, bool recursed, ParseMode parseMode)</a>
<a href="../engine/parser/Parser.cs.html#283"><b>283</b><i>Token</i> unused;</a>
<a href="../engine/parser/Parser.cs.html#313"><b>313</b>private static bool IgnoreTokenWhenUpdatingPreviousFirstLast(<i>Token</i> token)</a>
<a href="../engine/parser/Parser.cs.html#322"><b>322</b><i>var</i> firstToken = _tokenizer.FirstToken;</a>
<a href="../engine/parser/Parser.cs.html#336"><b>336</b><i>var</i> lastToken = _tokenizer.LastToken;</a>
<a href="../engine/parser/Parser.cs.html#376"><b>376</b><i>Token</i> token = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#437"><b>437</b>private <i>Token</i> NextToken()</a>
<a href="../engine/parser/Parser.cs.html#439"><b>439</b><i>Token</i> token = _ungotToken ?? _tokenizer.NextToken();</a>
<a href="../engine/parser/Parser.cs.html#444"><b>444</b>private <i>Token</i> PeekToken()</a>
<a href="../engine/parser/Parser.cs.html#446"><b>446</b><i>Token</i> token = _ungotToken ?? _tokenizer.NextToken();</a>
<a href="../engine/parser/Parser.cs.html#452"><b>452</b>private <i>Token</i> NextMemberAccessToken(bool allowLBracket)</a>
<a href="../engine/parser/Parser.cs.html#460"><b>460</b>private <i>Token</i> NextInvokeMemberToken()</a>
<a href="../engine/parser/Parser.cs.html#468"><b>468</b>private <i>Token</i> NextLBracket()</a>
<a href="../engine/parser/Parser.cs.html#497"><b>497</b>private void UngetToken(<i>Token</i> token)</a>
<a href="../engine/parser/Parser.cs.html#516"><b>516</b><i>Token</i> ungotToken = _ungotToken;</a>
<a href="../engine/parser/Parser.cs.html#521"><b>521</b><i>Token</i> rescan = _tokenizer.NextToken();</a>
<a href="../engine/parser/Parser.cs.html#542"><b>542</b>private void Resync(<i>Token</i> token)</a>
<a href="../engine/parser/Parser.cs.html#554"><b>554</b>private static bool IsSpecificParameter(<i>Token</i> token, string parameter)</a>
<a href="../engine/parser/Parser.cs.html#563"><b>563</b><i>var</i> terminatorToken = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#625"><b>625</b><i>var</i> token = obj as <i>Token</i>;</a>
<a href="../engine/parser/Parser.cs.html#652"><b>652</b>internal static IScriptExtent ExtentOf(<i>Token</i> first, <i>Token</i> last) { return ExtentOf(first.Extent, last.Extent); }</a>
<a href="../engine/parser/Parser.cs.html#656"><b>656</b>internal static IScriptExtent ExtentOf(Ast first, <i>Token</i> last) { return ExtentOf(first.Extent, last.Extent); }</a>
<a href="../engine/parser/Parser.cs.html#658"><b>658</b>internal static IScriptExtent ExtentOf(<i>Token</i> first, Ast last) { return ExtentOf(first.Extent, last.Extent); }</a>
<a href="../engine/parser/Parser.cs.html#662"><b>662</b>internal static IScriptExtent ExtentOf(IScriptExtent first, <i>Token</i> last) { return ExtentOf(first, last.Extent); }</a>
<a href="../engine/parser/Parser.cs.html#666"><b>666</b>internal static IScriptExtent ExtentOf(<i>Token</i> first, IScriptExtent last) { return ExtentOf(first.Extent, last); }</a>
<a href="../engine/parser/Parser.cs.html#669"><b>669</b>internal static IScriptExtent Before(<i>Token</i> token) { return Before(token.Extent); }</a>
<a href="../engine/parser/Parser.cs.html#673"><b>673</b>internal static IScriptExtent After(<i>Token</i> token) { return After(token.Extent); }</a>
<a href="../engine/parser/Parser.cs.html#723"><b>723</b><i>Token</i>[] throwAwayTokens;</a>
<a href="../engine/parser/Parser.cs.html#775"><b>775</b>private ScriptBlockAst ScriptBlockRule(<i>Token</i> lCurly, bool isFilter)</a>
<a href="../engine/parser/Parser.cs.html#780"><b>780</b>private ScriptBlockAst ScriptBlockRule(<i>Token</i> lCurly, bool isFilter, StatementAst predefinedStatementAst)</a>
<a href="../engine/parser/Parser.cs.html#820"><b>820</b><i>var</i> token = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#861"><b>861</b><i>Token</i> paramToken = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#869"><b>869</b><i>Token</i> lparen = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#881"><b>881</b><i>Token</i> rParen = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#927"><b>927</b><i>Token</i> commaToken = null;</a>
<a href="../engine/parser/Parser.cs.html#981"><b>981</b><i>Token</i> token = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#1006"><b>1006</b><i>Token</i> equalsToken = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#1067"><b>1067</b><i>var</i> lBracket = NextLBracket();</a>
<a href="../engine/parser/Parser.cs.html#1075"><b>1075</b><i>Token</i> firstTypeNameToken;</a>
<a href="../engine/parser/Parser.cs.html#1088"><b>1088</b><i>Token</i> lParenOrRBracket = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#1109"><b>1109</b><i>Token</i> rParen = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#1122"><b>1122</b><i>Token</i> rBracket = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#1144"><b>1144</b><i>var</i> typeToken = new Token((InternalScriptExtent)ExtentOf(lBracket, lParenOrRBracket),</a>
<a href="../engine/parser/Parser.cs.html#1173"><b>1173</b><i>Token</i> commaToken = null;</a>
<a href="../engine/parser/Parser.cs.html#1188"><b>1188</b><i>Token</i> token = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#1277"><b>1277</b>private ITypeName TypeNameRule(bool allowAssemblyQualifiedNames, out <i>Token</i> firstTypeNameToken)</a>
<a href="../engine/parser/Parser.cs.html#1320"><b>1320</b><i>Token</i> typeName = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#1339"><b>1339</b>private ITypeName FinishTypeNameRule(<i>Token</i> typeName, bool unBracketedGenericArg = false, bool allowAssemblyQualifiedNames = true)</a>
<a href="../engine/parser/Parser.cs.html#1342"><b>1342</b><i>Token</i> token = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#1345"><b>1345</b><i>var</i> lbracket = token;</a>
<a href="../engine/parser/Parser.cs.html#1403"><b>1403</b>private ITypeName GetSingleGenericArgument(<i>Token</i> firstToken)</a>
<a href="../engine/parser/Parser.cs.html#1412"><b>1412</b><i>Token</i> token = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#1425"><b>1425</b><i>Token</i> rBracket = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#1440"><b>1440</b>private ITypeName GenericTypeArgumentsRule(<i>Token</i> genericTypeName, <i>Token</i> firstToken, bool unBracketedGenericArg)</a>
<a href="../engine/parser/Parser.cs.html#1449"><b>1449</b><i>Token</i> commaOrRBracketToken;</a>
<a href="../engine/parser/Parser.cs.html#1450"><b>1450</b><i>Token</i> token;</a>
<a href="../engine/parser/Parser.cs.html#1519"><b>1519</b>private ITypeName CompleteArrayTypeName(ITypeName elementType, TypeName typeForAssemblyQualification, <i>Token</i> firstTokenAfterLBracket)</a>
<a href="../engine/parser/Parser.cs.html#1523"><b>1523</b><i>Token</i> token;</a>
<a href="../engine/parser/Parser.cs.html#1529"><b>1529</b><i>Token</i> lastComma;</a>
<a href="../engine/parser/Parser.cs.html#1604"><b>1604</b>private bool CompleteScriptBlockBody(<i>Token</i> lCurly, ref IScriptExtent bodyExtent, out IScriptExtent fullBodyExtent)</a>
<a href="../engine/parser/Parser.cs.html#1610"><b>1610</b><i>Token</i> rCurly = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#1640"><b>1640</b><i>Token</i> token = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#1657"><b>1657</b>private ScriptBlockAst ScriptBlockBodyRule(<i>Token</i> lCurly, List&lt;UsingStatementAst&gt; usingStatements, ParamBlockAst paramBlockAst, bool isFilter, StatementAst predefinedStatementAst)</a>
<a href="../engine/parser/Parser.cs.html#1663"><b>1663</b><i>Token</i> token = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#1702"><b>1702</b>private ScriptBlockAst NamedBlockListRule(<i>Token</i> lCurly, List&lt;UsingStatementAst&gt; usingStatements, ParamBlockAst paramBlockAst)</a>
<a href="../engine/parser/Parser.cs.html#1725"><b>1725</b><i>Token</i> blockNameToken = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#1831"><b>1831</b><i>Token</i> lCurly = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#1842"><b>1842</b><i>Token</i> rCurly = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#1905"><b>1905</b><i>Token</i> token = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#1952"><b>1952</b><i>Token</i> token = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#2132"><b>2132</b><i>Token</i> token;</a>
<a href="../engine/parser/Parser.cs.html#2136"><b>2136</b>private StringConstantExpressionAst SimpleNameRule(out <i>Token</i> token)</a>
<a href="../engine/parser/Parser.cs.html#2176"><b>2176</b><i>Token</i> token = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#2205"><b>2205</b>private BreakStatementAst BreakStatementRule(<i>Token</i> breakToken)</a>
<a href="../engine/parser/Parser.cs.html#2218"><b>2218</b>private ContinueStatementAst ContinueStatementRule(<i>Token</i> continueToken)</a>
<a href="../engine/parser/Parser.cs.html#2231"><b>2231</b>private ReturnStatementAst ReturnStatementRule(<i>Token</i> token)</a>
<a href="../engine/parser/Parser.cs.html#2243"><b>2243</b>private ExitStatementAst ExitStatementRule(<i>Token</i> token)</a>
<a href="../engine/parser/Parser.cs.html#2255"><b>2255</b>private ThrowStatementAst ThrowStatementRule(<i>Token</i> token)</a>
<a href="../engine/parser/Parser.cs.html#2282"><b>2282</b><i>Token</i> token = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#2310"><b>2310</b>private StatementAst BlockStatementRule(<i>Token</i> kindToken)</a>
<a href="../engine/parser/Parser.cs.html#2339"><b>2339</b>private bool InlineScriptRule(<i>Token</i> inlineScriptToken, List&lt;CommandElementAst&gt; elements)</a>
<a href="../engine/parser/Parser.cs.html#2350"><b>2350</b><i>Token</i> lCurly = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#2369"><b>2369</b>private StatementAst IfStatementRule(<i>Token</i> ifToken)</a>
<a href="../engine/parser/Parser.cs.html#2384"><b>2384</b><i>Token</i> keyword = ifToken;</a>
<a href="../engine/parser/Parser.cs.html#2389"><b>2389</b><i>Token</i> lParen = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#2424"><b>2424</b><i>Token</i> rParen = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#2512"><b>2512</b>private StatementAst SwitchStatementRule(LabelToken labelToken, <i>Token</i> switchToken)</a>
<a href="../engine/parser/Parser.cs.html#2551"><b>2551</b>Dictionary&lt;string, Tuple&lt;<i>Token</i>, Ast&gt;&gt; specifiedFlags = null; // Only used to track all flags specified for the error ast</a>
<a href="../engine/parser/Parser.cs.html#2553"><b>2553</b><i>Token</i> switchParameterToken = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#2559"><b>2559</b>specifiedFlags ??= new Dictionary&lt;string, Tuple&lt;<i>Token</i>, Ast&gt;&gt;();</a>
<a href="../engine/parser/Parser.cs.html#2568"><b>2568</b>specifiedFlags.Add(&quot;regex&quot;, new Tuple&lt;<i>Token</i>, Ast&gt;(switchParameterToken, null));</a>
<a href="../engine/parser/Parser.cs.html#2578"><b>2578</b>specifiedFlags.Add(&quot;wildcard&quot;, new Tuple&lt;<i>Token</i>, Ast&gt;(switchParameterToken, null));</a>
<a href="../engine/parser/Parser.cs.html#2588"><b>2588</b>specifiedFlags.Add(&quot;exact&quot;, new Tuple&lt;<i>Token</i>, Ast&gt;(switchParameterToken, null));</a>
<a href="../engine/parser/Parser.cs.html#2597"><b>2597</b>specifiedFlags.Add(&quot;casesensitive&quot;, new Tuple&lt;<i>Token</i>, Ast&gt;(switchParameterToken, null));</a>
<a href="../engine/parser/Parser.cs.html#2606"><b>2606</b>specifiedFlags.Add(&quot;parallel&quot;, new Tuple&lt;<i>Token</i>, Ast&gt;(switchParameterToken, null));</a>
<a href="../engine/parser/Parser.cs.html#2625"><b>2625</b>specifiedFlags.Add(&quot;file&quot;, new Tuple&lt;<i>Token</i>, Ast&gt;(switchParameterToken, null));</a>
<a href="../engine/parser/Parser.cs.html#2636"><b>2636</b>specifiedFlags.Add(&quot;file&quot;, new Tuple&lt;<i>Token</i>, Ast&gt;(switchParameterToken, condition));</a>
<a href="../engine/parser/Parser.cs.html#2656"><b>2656</b>specifiedFlags ??= new Dictionary&lt;string, Tuple&lt;<i>Token</i>, Ast&gt;&gt;();</a>
<a href="../engine/parser/Parser.cs.html#2657"><b>2657</b>specifiedFlags.Add(VERBATIM_ARGUMENT, new Tuple&lt;<i>Token</i>, Ast&gt;(switchParameterToken, null));</a>
<a href="../engine/parser/Parser.cs.html#2660"><b>2660</b><i>Token</i> lParen = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#2694"><b>2694</b><i>Token</i> rParen = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#2730"><b>2730</b><i>Token</i> lCurly = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#2734"><b>2734</b><i>Token</i> rCurly = null;</a>
<a href="../engine/parser/Parser.cs.html#2755"><b>2755</b><i>Token</i> token = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#2862"><b>2862</b>private StatementAst ConfigurationStatementRule(IEnumerable&lt;AttributeAst&gt; customAttributes, <i>Token</i> configurationToken)</a>
<a href="../engine/parser/Parser.cs.html#2880"><b>2880</b><i>Token</i> configurationNameToken = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#2881"><b>2881</b><i>Token</i> configurationKeywordToken = configurationNameToken;</a>
<a href="../engine/parser/Parser.cs.html#3063"><b>3063</b><i>Token</i> lCurly = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#3285"><b>3285</b>private ExpressionAst GetWordOrExpression(<i>Token</i> keywordToken)</a>
<a href="../engine/parser/Parser.cs.html#3287"><b>3287</b><i>Token</i> nameToken = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#3312"><b>3312</b>private StatementAst ForeachStatementRule(LabelToken labelToken, <i>Token</i> forEachToken)</a>
<a href="../engine/parser/Parser.cs.html#3334"><b>3334</b><i>Token</i> foreachParameterToken = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#3374"><b>3374</b><i>Token</i> lParen = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#3390"><b>3390</b><i>Token</i> token = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#3408"><b>3408</b><i>Token</i> inToken = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#3435"><b>3435</b><i>Token</i> rParen = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#3474"><b>3474</b>private StatementAst ForStatementRule(LabelToken labelToken, <i>Token</i> forToken)</a>
<a href="../engine/parser/Parser.cs.html#3498"><b>3498</b><i>Token</i> lParen = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#3544"><b>3544</b><i>Token</i> rParen = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#3585"><b>3585</b>private StatementAst WhileStatementRule(LabelToken labelToken, <i>Token</i> whileToken)</a>
<a href="../engine/parser/Parser.cs.html#3595"><b>3595</b><i>Token</i> lParen = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#3632"><b>3632</b><i>Token</i> rParen = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#3681"><b>3681</b>private StatementAst DynamicKeywordStatementRule(<i>Token</i> functionName, DynamicKeyword keywordData)</a>
<a href="../engine/parser/Parser.cs.html#3746"><b>3746</b><i>Token</i> nameToken = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#3769"><b>3769</b><i>Token</i> lCurly = null;</a>
<a href="../engine/parser/Parser.cs.html#4007"><b>4007</b><i>Token</i> nextToken = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#4053"><b>4053</b><i>Token</i> functionName,</a>
<a href="../engine/parser/Parser.cs.html#4060"><b>4060</b>private StatementAst DoWhileStatementRule(LabelToken labelToken, <i>Token</i> doToken)</a>
<a href="../engine/parser/Parser.cs.html#4072"><b>4072</b><i>Token</i> rParen = null;</a>
<a href="../engine/parser/Parser.cs.html#4073"><b>4073</b><i>Token</i> whileOrUntilToken = null;</a>
<a href="../engine/parser/Parser.cs.html#4104"><b>4104</b><i>Token</i> lParen = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#4168"><b>4168</b>private StatementAst ClassDefinitionRule(List&lt;AttributeBaseAst&gt; customAttributes, <i>Token</i> classToken)</a>
<a href="../engine/parser/Parser.cs.html#4197"><b>4197</b><i>Token</i> classNameToken;</a>
<a href="../engine/parser/Parser.cs.html#4220"><b>4220</b><i>Token</i> colonToken = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#4226"><b>4226</b><i>Token</i> unused;</a>
<a href="../engine/parser/Parser.cs.html#4227"><b>4227</b><i>Token</i> commaToken = null;</a>
<a href="../engine/parser/Parser.cs.html#4254"><b>4254</b><i>Token</i> lCurly = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#4294"><b>4294</b><i>var</i> rCurly = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#4364"><b>4364</b><i>Token</i> staticToken = null;</a>
<a href="../engine/parser/Parser.cs.html#4365"><b>4365</b><i>Token</i> hiddenToken = null;</a>
<a href="../engine/parser/Parser.cs.html#4366"><b>4366</b><i>Token</i> token = null;</a>
<a href="../engine/parser/Parser.cs.html#4500"><b>4500</b><i>var</i> assignToken = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#4524"><b>4524</b><i>Token</i> terminatorToken = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#4604"><b>4604</b>private static bool TryUseTokenAsSimpleName(<i>Token</i> token)</a>
<a href="../engine/parser/Parser.cs.html#4647"><b>4647</b>private <i>Token</i> NextTypeIdentifierToken()</a>
<a href="../engine/parser/Parser.cs.html#4655"><b>4655</b><i>Token</i> typeName = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#4670"><b>4670</b>private StatementAst EnumDefinitionRule(List&lt;AttributeBaseAst&gt; customAttributes, <i>Token</i> enumToken)</a>
<a href="../engine/parser/Parser.cs.html#4705"><b>4705</b><i>Token</i> colonToken = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#4711"><b>4711</b><i>Token</i> unused;</a>
<a href="../engine/parser/Parser.cs.html#4736"><b>4736</b><i>Token</i> lCurly = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#4759"><b>4759</b><i>var</i> rCurly = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#4815"><b>4815</b><i>Token</i> assignToken = null;</a>
<a href="../engine/parser/Parser.cs.html#4844"><b>4844</b><i>Token</i> terminatorToken = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#4867"><b>4867</b>private StatementAst UsingStatementRule(<i>Token</i> usingToken)</a>
<a href="../engine/parser/Parser.cs.html#4882"><b>4882</b><i>var</i> directiveToken = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#4921"><b>4921</b><i>var</i> itemToken = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#4975"><b>4975</b><i>var</i> equalsToken = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#4980"><b>4980</b><i>var</i> aliasToken = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#5129"><b>5129</b>private StatementAst MethodDeclarationRule(<i>Token</i> functionNameToken, string className, bool isStaticMethod)</a>
<a href="../engine/parser/Parser.cs.html#5142"><b>5142</b><i>Token</i> lParen = this.PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#5145"><b>5145</b><i>Token</i> rParen = null;</a>
<a href="../engine/parser/Parser.cs.html#5161"><b>5161</b><i>Token</i> baseToken = null;</a>
<a href="../engine/parser/Parser.cs.html#5171"><b>5171</b><i>Token</i> colonToken = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#5221"><b>5221</b><i>Token</i> lCurly = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#5277"><b>5277</b>private StatementAst FunctionDeclarationRule(<i>Token</i> functionToken)</a>
<a href="../engine/parser/Parser.cs.html#5289"><b>5289</b><i>Token</i> functionNameToken = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#5330"><b>5330</b><i>Token</i> rParen;</a>
<a href="../engine/parser/Parser.cs.html#5333"><b>5333</b><i>Token</i> lCurly = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#5376"><b>5376</b>private List&lt;ParameterAst&gt; FunctionParameterDeclarationRule(out IScriptExtent endErrorStatement, out <i>Token</i> rParen)</a>
<a href="../engine/parser/Parser.cs.html#5385"><b>5385</b><i>Token</i> lParen = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#5410"><b>5410</b>private StatementAst TrapStatementRule(<i>Token</i> trapToken)</a>
<a href="../engine/parser/Parser.cs.html#5464"><b>5464</b><i>Token</i> catchToken = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#5472"><b>5472</b><i>Token</i> commaToken = null;</a>
<a href="../engine/parser/Parser.cs.html#5557"><b>5557</b>private StatementAst TryStatementRule(<i>Token</i> tryToken)</a>
<a href="../engine/parser/Parser.cs.html#5597"><b>5597</b><i>Token</i> finallyToken = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#5636"><b>5636</b>private StatementAst DataStatementRule(<i>Token</i> dataToken)</a>
<a href="../engine/parser/Parser.cs.html#5656"><b>5656</b><i>Token</i> supportedCommandToken = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#5673"><b>5673</b><i>Token</i> commaToken = null;</a>
<a href="../engine/parser/Parser.cs.html#5754"><b>5754</b><i>Token</i> assignToken = null;</a>
<a href="../engine/parser/Parser.cs.html#5769"><b>5769</b><i>var</i> token = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#5813"><b>5813</b><i>Token</i> currentChainOperatorToken = null;</a>
<a href="../engine/parser/Parser.cs.html#5814"><b>5814</b><i>Token</i> nextToken = null;</a>
<a href="../engine/parser/Parser.cs.html#5822"><b>5822</b><i>Token</i> firstPipelineToken = null;</a>
<a href="../engine/parser/Parser.cs.html#5972"><b>5972</b><i>Token</i> nextToken = null;</a>
<a href="../engine/parser/Parser.cs.html#6265"><b>6265</b>private ExpressionAst GetCommandArgument(CommandArgumentContext context, <i>Token</i> token)</a>
<a href="../engine/parser/Parser.cs.html#6270"><b>6270</b><i>Token</i> commaToken = null;</a>
<a href="../engine/parser/Parser.cs.html#6444"><b>6444</b><i>Token</i> firstToken;</a>
<a href="../engine/parser/Parser.cs.html#6457"><b>6457</b><i>Token</i> token = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#6696"><b>6696</b><i>Token</i> token = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#6829"><b>6829</b><i>Token</i> token = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#6848"><b>6848</b>Stack&lt;<i>Token</i>&gt; operatorStack = new Stack&lt;<i>Token</i>&gt;();</a>
<a href="../engine/parser/Parser.cs.html#6893"><b>6893</b><i>Token</i> op = operatorStack.Pop();</a>
<a href="../engine/parser/Parser.cs.html#6964"><b>6964</b><i>Token</i> commaToken = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#7034"><b>7034</b><i>Token</i> token;</a>
<a href="../engine/parser/Parser.cs.html#7146"><b>7146</b><i>var</i> memberAccessToken = _ungotToken != null ? null : NextMemberAccessToken(false);</a>
<a href="../engine/parser/Parser.cs.html#7227"><b>7227</b><i>Token</i> token = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#7298"><b>7298</b>private ExpressionAst CheckPostPrimaryExpressionOperators(<i>Token</i> token, ExpressionAst expr)</a>
<a href="../engine/parser/Parser.cs.html#7320"><b>7320</b>private ExpressionAst HashExpressionRule(<i>Token</i> atCurlyToken, bool parsingSchemaElement)</a>
<a href="../engine/parser/Parser.cs.html#7344"><b>7344</b><i>Token</i> token = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#7354"><b>7354</b><i>Token</i> rCurly = NextToken();</a>
<a href="../engine/parser/Parser.cs.html#7389"><b>7389</b><i>Token</i> equals;</a>
<a href="../engine/parser/Parser.cs.html#7472"><b>7472</b>private ExpressionAst ScriptBlockExpressionRule(<i>Token</i> lCurly)</a>
<a href="../engine/parser/Parser.cs.html#7498"><b>7498</b>private ExpressionAst SubExpressionRule(<i>Token</i> firstToken)</a>
<a href="../engine/parser/Parser.cs.html#7508"><b>7508</b><i>Token</i> rParen;</a>
<a href="../engine/parser/Parser.cs.html#7552"><b>7552</b>private ExpressionAst ParenthesizedExpressionRule(<i>Token</i> lParen)</a>
<a href="../engine/parser/Parser.cs.html#7556"><b>7556</b><i>Token</i> rParen;</a>
<a href="../engine/parser/Parser.cs.html#7603"><b>7603</b>List&lt;<i>Token</i>&gt; newNestedTokens = _savingTokens ? new List&lt;<i>Token</i>&gt;() : null;</a>
<a href="../engine/parser/Parser.cs.html#7648"><b>7648</b>if (_savingTokens) { expandableStringToken.NestedTokens = new ReadOnlyCollection&lt;<i>Token</i>&gt;(newNestedTokens); }</a>
<a href="../engine/parser/Parser.cs.html#7688"><b>7688</b><i>Token</i> token = PeekToken();</a>
<a href="../engine/parser/Parser.cs.html#7697"><b>7697</b>private ExpressionAst MemberAccessRule(ExpressionAst targetExpr, <i>Token</i> operatorToken)</a>
<a href="../engine/parser/Parser.cs.html#7720"><b>7720</b><i>Token</i> lParen = NextInvokeMemberToken();</a>
<a href="../engine/parser/Parser.cs.html#7738"><b>7738</b>private ExpressionAst MemberInvokeRule(ExpressionAst targetExpr, <i>Token</i> lBracket, <i>Token</i> operatorToken, CommandElementAst member)</a>
<a href="../engine/parser/Parser.cs.html#7772"><b>7772</b>private List&lt;ExpressionAst&gt; InvokeParamParenListRule(<i>Token</i> lParen, out IScriptExtent lastExtent)</a>
<a href="../engine/parser/Parser.cs.html#7785"><b>7785</b><i>Token</i> comma = null;</a>
<a href="../engine/parser/Parser.cs.html#7786"><b>7786</b><i>Token</i> rParen = null;</a>
<a href="../engine/parser/Parser.cs.html#7853"><b>7853</b>private ExpressionAst ElementAccessRule(ExpressionAst primaryExpression, <i>Token</i> lBracket)</a>
<a href="../engine/parser/Parser.cs.html#7874"><b>7874</b><i>Token</i> rBracket = NextToken();</a>
</div>
<div class="rF"><div class="rN">engine\parser\token.cs (6)</div>
<a href="../engine/parser/token.cs.html#1400"><b>1400</b>private ReadOnlyCollection&lt;<i>Token</i>&gt; _nestedTokens;</a>
<a href="../engine/parser/token.cs.html#1402"><b>1402</b>internal StringExpandableToken(InternalScriptExtent scriptExtent, TokenKind tokenKind, string value, string formatString, List&lt;<i>Token</i>&gt; nestedTokens, TokenFlags flags)</a>
<a href="../engine/parser/token.cs.html#1407"><b>1407</b>_nestedTokens = new ReadOnlyCollection&lt;<i>Token</i>&gt;(nestedTokens.ToArray());</a>
<a href="../engine/parser/token.cs.html#1413"><b>1413</b>internal static void ToDebugString(ReadOnlyCollection&lt;<i>Token</i>&gt; nestedTokens,</a>
<a href="../engine/parser/token.cs.html#1418"><b>1418</b>foreach (<i>Token</i> token in nestedTokens)</a>
<a href="../engine/parser/token.cs.html#1431"><b>1431</b>public ReadOnlyCollection&lt;<i>Token</i>&gt; NestedTokens</a>
</div>
<div class="rF"><div class="rN">engine\parser\tokenizer.cs (60)</div>
<a href="../engine/parser/tokenizer.cs.html#588"><b>588</b>internal <i>Token</i> FirstToken;</a>
<a href="../engine/parser/tokenizer.cs.html#589"><b>589</b>internal <i>Token</i> LastToken;</a>
<a href="../engine/parser/tokenizer.cs.html#591"><b>591</b>internal List&lt;<i>Token</i>&gt; TokenList;</a>
<a href="../engine/parser/tokenizer.cs.html#746"><b>746</b>internal List&lt;<i>Token</i>&gt; TokenList { get; set; }</a>
<a href="../engine/parser/tokenizer.cs.html#748"><b>748</b>internal <i>Token</i> FirstToken { get; private set; }</a>
<a href="../engine/parser/tokenizer.cs.html#750"><b>750</b>internal <i>Token</i> LastToken { get; private set; }</a>
<a href="../engine/parser/tokenizer.cs.html#752"><b>752</b>private List&lt;<i>Token</i>&gt; RequiresTokens { get; set; }</a>
<a href="../engine/parser/tokenizer.cs.html#762"><b>762</b>internal void Initialize(string fileName, string input, List&lt;<i>Token</i>&gt; tokenList)</a>
<a href="../engine/parser/tokenizer.cs.html#818"><b>818</b>TokenList = (TokenList != null) ? new List&lt;<i>Token</i>&gt;() : null;</a>
<a href="../engine/parser/tokenizer.cs.html#1031"><b>1031</b>internal void Resync(<i>Token</i> token)</a>
<a href="../engine/parser/tokenizer.cs.html#1080"><b>1080</b>internal void RemoveTokensFromListDuringResync(List&lt;<i>Token</i>&gt; tokenList, int start)</a>
<a href="../engine/parser/tokenizer.cs.html#1102"><b>1102</b>internal void ReplaceSavedTokens(<i>Token</i> firstOldToken, <i>Token</i> lastOldToken, <i>Token</i> newToken)</a>
<a href="../engine/parser/tokenizer.cs.html#1214"><b>1214</b>private <i>Token</i> NewCommentToken()</a>
<a href="../engine/parser/tokenizer.cs.html#1219"><b>1219</b>private T SaveToken&lt;T&gt;(T token) where T : <i>Token</i></a>
<a href="../engine/parser/tokenizer.cs.html#1249"><b>1249</b>private <i>Token</i> NewToken(TokenKind kind)</a>
<a href="../engine/parser/tokenizer.cs.html#1254"><b>1254</b>private <i>Token</i> NewNumberToken(object value)</a>
<a href="../engine/parser/tokenizer.cs.html#1259"><b>1259</b>private <i>Token</i> NewParameterToken(string name, bool sawColon)</a>
<a href="../engine/parser/tokenizer.cs.html#1274"><b>1274</b>private StringToken NewStringExpandableToken(string value, string formatString, TokenKind tokenKind, List&lt;<i>Token</i>&gt; nestedTokens, TokenFlags flags)</a>
<a href="../engine/parser/tokenizer.cs.html#1291"><b>1291</b>private <i>Token</i> NewGenericExpandableToken(string value, string formatString, List&lt;<i>Token</i>&gt; nestedTokens)</a>
<a href="../engine/parser/tokenizer.cs.html#1296"><b>1296</b>private <i>Token</i> NewGenericToken(string value)</a>
<a href="../engine/parser/tokenizer.cs.html#1301"><b>1301</b>private <i>Token</i> NewInputRedirectionToken()</a>
<a href="../engine/parser/tokenizer.cs.html#1306"><b>1306</b>private <i>Token</i> NewFileRedirectionToken(int from, bool append, bool fromSpecifiedExplicitly)</a>
<a href="../engine/parser/tokenizer.cs.html#1322"><b>1322</b>private <i>Token</i> NewMergingRedirectionToken(int from, int to)</a>
<a href="../engine/parser/tokenizer.cs.html#1803"><b>1803</b><i>var</i> token = NewCommentToken();</a>
<a href="../engine/parser/tokenizer.cs.html#1811"><b>1811</b>RequiresTokens = new List&lt;<i>Token</i>&gt;();</a>
<a href="../engine/parser/tokenizer.cs.html#2371"><b>2371</b>private <i>Token</i> ScanStringLiteral()</a>
<a href="../engine/parser/tokenizer.cs.html#2378"><b>2378</b>private <i>Token</i> ScanSubExpression(bool hereString)</a>
<a href="../engine/parser/tokenizer.cs.html#2465"><b>2465</b>private TokenFlags ScanStringExpandable(StringBuilder sb, StringBuilder formatSb, List&lt;<i>Token</i>&gt; nestedTokens)</a>
<a href="../engine/parser/tokenizer.cs.html#2534"><b>2534</b>private bool ScanDollarInStringExpandable(StringBuilder sb, StringBuilder formatSb, bool hereString, List&lt;<i>Token</i>&gt; nestedTokens)</a>
<a href="../engine/parser/tokenizer.cs.html#2541"><b>2541</b><i>Token</i> nestedToken = null;</a>
<a href="../engine/parser/tokenizer.cs.html#2584"><b>2584</b>private <i>Token</i> ScanStringExpandable()</a>
<a href="../engine/parser/tokenizer.cs.html#2588"><b>2588</b>List&lt;<i>Token</i>&gt; nestedTokens = new List&lt;<i>Token</i>&gt;();</a>
<a href="../engine/parser/tokenizer.cs.html#2701"><b>2701</b>private <i>Token</i> ScanHereStringLiteral()</a>
<a href="../engine/parser/tokenizer.cs.html#2771"><b>2771</b>private <i>Token</i> ScanHereStringExpandable()</a>
<a href="../engine/parser/tokenizer.cs.html#2783"><b>2783</b>List&lt;<i>Token</i>&gt; nestedTokens = new List&lt;<i>Token</i>&gt;();</a>
<a href="../engine/parser/tokenizer.cs.html#2888"><b>2888</b>private <i>Token</i> ScanVariable(bool splatted, bool inStringExpandable)</a>
<a href="../engine/parser/tokenizer.cs.html#3201"><b>3201</b>private <i>Token</i> ScanParameter()</a>
<a href="../engine/parser/tokenizer.cs.html#3356"><b>3356</b>private <i>Token</i> CheckOperatorInCommandMode(char c, TokenKind tokenKind)</a>
<a href="../engine/parser/tokenizer.cs.html#3366"><b>3366</b>private <i>Token</i> CheckOperatorInCommandMode(char c1, char c2, TokenKind tokenKind)</a>
<a href="../engine/parser/tokenizer.cs.html#3379"><b>3379</b>private <i>Token</i> ScanGenericToken(char firstChar)</a>
<a href="../engine/parser/tokenizer.cs.html#3386"><b>3386</b>private <i>Token</i> ScanGenericToken(char firstChar, char surrogateCharacter)</a>
<a href="../engine/parser/tokenizer.cs.html#3398"><b>3398</b>private <i>Token</i> ScanGenericToken(StringBuilder sb)</a>
<a href="../engine/parser/tokenizer.cs.html#3424"><b>3424</b>List&lt;<i>Token</i>&gt; nestedTokens = new List&lt;<i>Token</i>&gt;();</a>
<a href="../engine/parser/tokenizer.cs.html#3900"><b>3900</b>private <i>Token</i> ScanNumber(char firstChar)</a>
<a href="../engine/parser/tokenizer.cs.html#4182"><b>4182</b>internal <i>Token</i> GetMemberAccessOperator(bool allowLBracket)</a>
<a href="../engine/parser/tokenizer.cs.html#4279"><b>4279</b>internal <i>Token</i> GetInvokeMemberOpenParen()</a>
<a href="../engine/parser/tokenizer.cs.html#4300"><b>4300</b>internal <i>Token</i> GetLBracket()</a>
<a href="../engine/parser/tokenizer.cs.html#4382"><b>4382</b>private <i>Token</i> ScanDot()</a>
<a href="../engine/parser/tokenizer.cs.html#4417"><b>4417</b>private <i>Token</i> ScanIdentifier(char firstChar)</a>
<a href="../engine/parser/tokenizer.cs.html#4477"><b>4477</b>private <i>Token</i> ScanTypeName()</a>
<a href="../engine/parser/tokenizer.cs.html#4505"><b>4505</b><i>var</i> result = NewToken(TokenKind.Identifier);</a>
<a href="../engine/parser/tokenizer.cs.html#4529"><b>4529</b><i>var</i> token = NewToken(TokenKind.Identifier);</a>
<a href="../engine/parser/tokenizer.cs.html#4589"><b>4589</b>private <i>Token</i> ScanLabel()</a>
<a href="../engine/parser/tokenizer.cs.html#4627"><b>4627</b>internal <i>Token</i> NextToken()</a>
</div>
<div class="rF"><div class="rN">engine\runtime\CompiledScriptBlock.cs (1)</div>
<a href="../engine/runtime/CompiledScriptBlock.cs.html#853"><b>853</b>Dictionary&lt;Ast, <i>Token</i>[]&gt; scriptBlockTokenCache,</a>
</div>
<div class="rF"><div class="rN">engine\ScriptCommandProcessor.cs (2)</div>
<a href="../engine/ScriptCommandProcessor.cs.html#144"><b>144</b>Dictionary&lt;Ast, <i>Token</i>[]&gt; scriptBlockTokenCache = new Dictionary&lt;Ast, <i>Token</i>[]&gt;();</a>
</div>
<div class="rF"><div class="rN">engine\Subsystem\CommandPrediction\CommandPrediction.cs (4)</div>
<a href="../engine/Subsystem/CommandPrediction/CommandPrediction.cs.html#60"><b>60</b>/// &lt;param name=&quot;astTokens&quot;&gt;The &lt;see cref=&quot;<i>Token</i>&quot;/&gt; objects from parsing the current command line input.&lt;/param&gt;</a>
<a href="../engine/Subsystem/CommandPrediction/CommandPrediction.cs.html#62"><b>62</b>public static Task&lt;List&lt;PredictionResult&gt;?&gt; PredictInputAsync(PredictionClient client, Ast ast, <i>Token</i>[] astTokens)</a>
<a href="../engine/Subsystem/CommandPrediction/CommandPrediction.cs.html#72"><b>72</b>/// &lt;param name=&quot;astTokens&quot;&gt;The &lt;see cref=&quot;<i>Token</i>&quot;/&gt; objects from parsing the current command line input.&lt;/param&gt;</a>
<a href="../engine/Subsystem/CommandPrediction/CommandPrediction.cs.html#75"><b>75</b>public static async Task&lt;List&lt;PredictionResult&gt;?&gt; PredictInputAsync(PredictionClient client, Ast ast, <i>Token</i>[] astTokens, int millisecondsTimeout)</a>
</div>
<div class="rF"><div class="rN">engine\Subsystem\CommandPrediction\ICommandPredictor.cs (5)</div>
<a href="../engine/Subsystem/CommandPrediction/ICommandPredictor.cs.html#164"><b>164</b>public IReadOnlyList&lt;<i>Token</i>&gt; InputTokens { get; }</a>
<a href="../engine/Subsystem/CommandPrediction/ICommandPredictor.cs.html#174"><b>174</b>public <i>Token</i>? TokenAtCursor { get; }</a>
<a href="../engine/Subsystem/CommandPrediction/ICommandPredictor.cs.html#186"><b>186</b>/// &lt;param name=&quot;inputTokens&quot;&gt;The &lt;see cref=&quot;<i>Token</i>&quot;/&gt; objects from parsing the current command line input.&lt;/param&gt;</a>
<a href="../engine/Subsystem/CommandPrediction/ICommandPredictor.cs.html#187"><b>187</b>public PredictionContext(Ast inputAst, <i>Token</i>[] inputTokens)</a>
<a href="../engine/Subsystem/CommandPrediction/ICommandPredictor.cs.html#211"><b>211</b>Ast ast = Parser.ParseInput(input, out <i>Token</i>[] tokens, out _);</a>
</div>
<div class="rF"><div class="rN">help\HelpCommentsParser.cs (21)</div>
<a href="../help/HelpCommentsParser.cs.html#526"><b>526</b>private static void CollectCommentText(<i>Token</i> comment, List&lt;string&gt; commentLines)</a>
<a href="../help/HelpCommentsParser.cs.html#696"><b>696</b>internal bool AnalyzeCommentBlock(List&lt;<i>Token</i>&gt; comments)</a>
<a href="../help/HelpCommentsParser.cs.html#704"><b>704</b>foreach (<i>Token</i> comment in comments)</a>
<a href="../help/HelpCommentsParser.cs.html#825"><b>825</b>internal static CommentHelpInfo GetHelpContents(List&lt;Language.<i>Token</i>&gt; comments, List&lt;string&gt; parameterDescriptions)</a>
<a href="../help/HelpCommentsParser.cs.html#834"><b>834</b>List&lt;Language.<i>Token</i>&gt; comments,</a>
<a href="../help/HelpCommentsParser.cs.html#938"><b>938</b>internal static bool IsCommentHelpText(List&lt;<i>Token</i>&gt; commentBlock)</a>
<a href="../help/HelpCommentsParser.cs.html#949"><b>949</b>private static List&lt;Language.<i>Token</i>&gt; GetCommentBlock(Language.<i>Token</i>[] tokens, ref int startIndex)</a>
<a href="../help/HelpCommentsParser.cs.html#951"><b>951</b>var result = new List&lt;Language.<i>Token</i>&gt;();</a>
<a href="../help/HelpCommentsParser.cs.html#958"><b>958</b>Language.<i>Token</i> current = tokens[i];</a>
<a href="../help/HelpCommentsParser.cs.html#987"><b>987</b>private static List&lt;Language.<i>Token</i>&gt; GetPrecedingCommentBlock(Language.<i>Token</i>[] tokens, int tokenIndex, int proximity)</a>
<a href="../help/HelpCommentsParser.cs.html#989"><b>989</b>var result = new List&lt;Language.<i>Token</i>&gt;();</a>
<a href="../help/HelpCommentsParser.cs.html#994"><b>994</b>Language.<i>Token</i> current = tokens[i];</a>
<a href="../help/HelpCommentsParser.cs.html#1014"><b>1014</b>private static int FirstTokenInExtent(Language.<i>Token</i>[] tokens, IScriptExtent extent, int startIndex = 0)</a>
<a href="../help/HelpCommentsParser.cs.html#1028"><b>1028</b>private static int LastTokenInExtent(Language.<i>Token</i>[] tokens, IScriptExtent extent, int startIndex)</a>
<a href="../help/HelpCommentsParser.cs.html#1044"><b>1044</b>private static List&lt;string&gt; GetParameterComments(Language.<i>Token</i>[] tokens, IParameterMetadataProvider ipmp, int startIndex)</a>
<a href="../help/HelpCommentsParser.cs.html#1093"><b>1093</b>internal static Tuple&lt;List&lt;Language.<i>Token</i>&gt;, List&lt;string&gt;&gt; GetHelpCommentTokens(IParameterMetadataProvider ipmp,</a>
<a href="../help/HelpCommentsParser.cs.html#1094"><b>1094</b>Dictionary&lt;Ast, <i>Token</i>[]&gt; scriptBlockTokenCache)</a>
<a href="../help/HelpCommentsParser.cs.html#1111"><b>1111</b>Language.<i>Token</i>[] tokens = null;</a>
<a href="../help/HelpCommentsParser.cs.html#1127"><b>1127</b>List&lt;Language.<i>Token</i>&gt; commentBlock;</a>
</div>
<div class="rF"><div class="rN">help\HelpSystem.cs (3)</div>
<a href="../help/HelpSystem.cs.html#782"><b>782</b>private readonly Lazy&lt;Dictionary&lt;Ast, <i>Token</i>[]&gt;&gt; _scriptBlockTokenCache = new Lazy&lt;Dictionary&lt;Ast, <i>Token</i>[]&gt;&gt;(isThreadSafe: true);</a>
<a href="../help/HelpSystem.cs.html#784"><b>784</b>internal Dictionary&lt;Ast, <i>Token</i>[]&gt; ScriptBlockTokenCache</a>
</div>
<div class="rF"><div class="rN">utils\RuntimeException.cs (2)</div>
<a href="../utils/RuntimeException.cs.html#307"><b>307</b>private <i>Token</i> _errorToken;</a>
<a href="../utils/RuntimeException.cs.html#309"><b>309</b>internal <i>Token</i> ErrorToken</a>
</div>
</div>
</body></html>